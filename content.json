{"meta":{"title":"APingStudio","subtitle":null,"description":"好少年光芒万丈","author":"RobertCarlson","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-02-11T06:08:01.568Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-02-11T06:08:01.569Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"分类","date":"2021-01-15T13:33:27.000Z","updated":"2021-02-11T06:57:59.245Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-02-11T06:08:01.569Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-02-11T06:08:01.570Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"bb","date":"2021-02-03T07:29:38.000Z","updated":"2021-02-03T08:07:01.038Z","comments":true,"path":"bb/index.html","permalink":"/bb/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-02-11T06:08:01.571Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-02-11T06:08:01.570Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"学习资料","date":"2021-02-05T06:13:57.000Z","updated":"2021-02-09T07:19:20.808Z","comments":true,"path":"materials/index.html","permalink":"/materials/index.html","excerpt":"","text":"推荐用chrome、QQ等主流浏览器打开，使用IE浏览器部分出现问题。 机器学习课件HTMLTensorflow与深度学习HTML十小时学会OPENCV数据分析Python基础"},{"title":"显然，这是一个留言板","date":"2021-01-28T09:10:20.000Z","updated":"2021-02-05T07:40:23.052Z","comments":true,"path":"guestbook/index.html","permalink":"/guestbook/index.html","excerpt":"","text":"欢迎留下你的足迹"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-02-11T06:08:01.572Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-02-11T06:08:01.573Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-02-11T06:08:01.574Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-02-11T06:08:01.573Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-02-11T06:08:01.575Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"timeline","date":"2021-01-28T03:20:51.000Z","updated":"2021-01-28T03:20:51.187Z","comments":true,"path":"timeline/index.html","permalink":"/timeline/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-02-11T06:08:01.575Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"《数字图像处理第四版》读书笔记","slug":"《数字图像处理第四版》读书笔记","date":"2021-02-11T06:17:36.000Z","updated":"2021-02-11T10:09:55.344Z","comments":true,"path":"2021/02/11/《数字图像处理第四版》读书笔记/","link":"","permalink":"/2021/02/11/《数字图像处理第四版》读书笔记/","excerpt":"","text":"《数字图像处理 第四版》读书笔记_ 关于本书 书名 《数字图像处理 第四版》 作者 冈萨雷斯美国 出版社 电子工业出版社 阅读日期 2021-1 豆瓣评分 8.7 我的评分 ☆☆☆☆ 内容简介在数字图像处理领域，本书作为主要教材已有40多年。第四版是作者在前三版的基础上修订而成的，是前三版的发展与延续。除保留前几版的大部分内容外，根据读者的反馈，作者对本书进行了全面修订，融入了近年来数字图像处理领域的重要进展，增加了几百幅新图像、几十个新图表和上百道新习题。全书共12章，即绪论、数字图像基础、灰度变换与空间滤波、频率域滤波、图像复原与重构、小波变换和其他图像变换、彩色图像处理、图像压缩和水印、形态学图像处理、图像分割、特征提取、图像模式分类。本书的读者对象主要是从事信号与信息处理、通信工程、电子科学与技术、信息工程、自动化、计算机科学与技术、地球物理、生物工程、生物医学工程、物理、化学、医学、遥感等领域的大学教师和科技工作者、研究生、大学本科高年级学生及工程技术人员。 第3章 灰度变换与空间滤波3.3 直方图处理$$h\\left(r_{k}\\right)=n_{k}$$ void CMFCApplication1View::histCompute(BYTE*image, int width, int height) { //计算直方图 //初始化直方图数组全为0，这个数组里存储的是对应灰度级的像素个数 int n; for (n = 0; n &lt; 256; n ++) hist[n] = 0; //参数image传入的是图片数组的地址，是一维数组的地址，image数组的内容是每个像素的灰度级 //而图片的二维的数组，此时要求二维转一维。 int i,j; BYTE gray;//灰度级 for(i = 0;i &lt; height;i++) for (j = 0; j &lt; width; j++) { gray = image[i * width + j]; hist[gray]++; } } 3.3.1 直方图（hist）均衡$$s=T(r), 0 \\leqslant r \\leqslant L-1$$r：待处理图像的灰度s：输出灰度值T()：变换（灰度映射）现在，做出以下假设： T(r)在区间0≤ r ≤L-1上是一个单调递增函数。——防止因灰度反转而产生伪像 定义域和值域相同，都为0≤ r ≤L-1，0≤ T(r) ≤L-1。——保证输出灰度的范围与输入相同 然后，作逆变换（反函数）$$r=T^{-1}(s), 0 \\leqslant s \\leqslant L-1$$此时，将1的条件改为T(r)在区间0≤ r ≤L-1上是一个严格单调递增函数。——保证s返回到r的映射是一对一的$$p_{s}(s)=p_{r}(r)\\left|\\frac{\\mathrm{d} r}{\\mathrm{~d} s}\\right|$$$$p_{s}(s)：输出值s的PDF（概率密度函数）$$$$p_{r}(r)：灰度值r的PDF$$$$s=T(r)=(L-1) \\int_{0}^{r} p_{r}(w) \\mathrm{d} w$$ $$ω：假积分变量\\\\int_{0}^{r} p_{r}(w) \\mathrm{d} w：累积分布函数（CDF）$$ 直方图均衡代码：$$D_{B}=\\frac{D_{m}}{A_{0}} \\cdot \\sum_{0}^{D_{A}} H_{A}\\left(D_{A}\\right)$$$$D_{m}：\\D_{A}：\\D_{B}：新的灰度级\\A_{0}：图像的总像素个数\\H_{A}（）：直方图$$ 第一步：计算输入图像直方图第二步：计算像素新的灰度级第三步：新灰度级 替换 原灰度级 void CMFCApplication1View::hisEqualiz(BYTE* image, int w, int h, BYTE* outImg) { //直方图均衡 //第一步 生成直方图 int his[256]; int n, i, j; for (n = 0; n &lt; 256; n++) his[n] = 0; for (i = 0; i &lt; h; i++) for (j = 0; j &lt; w; j++) his[image[i * w + j]]++;//精简了代码 //第二步 计算新的灰度级 for (n = 1; n &lt; 256; n++)//计算his[255] his[n] += his[n - 1]; BYTE gray[256]; float cons;//系数 cons = 255. / his[255]; for (n = 0; n &lt; 256; n++) gray[n] = (BYTE)(cons * his[n]); //用新的灰度级替换原来的灰度级 for (i = 0; i &lt; h; i++) { for (j = 0; j &lt; w; j++) outImg[i * w + j] = gray[image[i * w + j]]; } } 3.3.2 直方图匹配（规定化）用于生成规定直方图的图像的方法。 第9章 形态学图像处理本章思维导图### 9.1 预备知识二维整数空间：像素的坐标三维整数空间：像素的坐标+离散灰度值高维整数空间：包含更多的图像分量，例如彩色分量、时变分量形态学运算使用集合来定义的，形态学集合包括目标元素和结构元（SE）两类元素的集合。目标元素：前景像素的集合结构元：根据前景像素和背景像素来规定。（有时候包含“不关心”元素）反射：$$\\hat{B}=｛w|w=-b，b\\in B｝$$$$\\hat{B}为相对于其原点的反射。$$平移：$$(B){z}=｛c|c=b+z，b\\in B｝$$$$(B){z}是B中坐标(x,y)已被(x+z_{1},y+z_{2})代替的点集。$$","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"python基础","slug":"python基础","date":"2021-02-03T07:56:56.000Z","updated":"2021-02-03T08:03:01.655Z","comments":true,"path":"2021/02/03/python基础/","link":"","permalink":"/2021/02/03/python基础/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"linux基础","slug":"linux基础","date":"2021-02-03T07:56:25.000Z","updated":"2021-02-03T08:10:20.324Z","comments":true,"path":"2021/02/03/linux基础/","link":"","permalink":"/2021/02/03/linux基础/","excerpt":"","text":"vi —— 终端中的编辑器目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vimvim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 # 查找 vi 的运行文件 $ which vi $ ls -l /usr/bin/vi $ ls -l /etc/alternatives/vi $ ls -l /usr/bin/vim.basic # 查找 vim 的运行文件 $ which vim $ ls -l /usr/bin/vim $ ls -l /etc/alternatives/vim $ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 $ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 $ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write &amp; quit 保存并退出 x 保存并退出 04. 常用命令命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序）1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 ‘x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： * dw # 从光标位置删除到单词末尾 * d0 # 从光标位置删除到一行的起始位置 * d} # 从光标位置删除到段落结尾 * ndd # 从光标位置向下连续删除 n 行 * d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码 * d&#39;a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 &gt; 或者 &lt; 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： :%s///g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： :%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： :s/旧文本/新文本/g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ :%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展末行命令 主要是针对文件进行操作的：保存、退出、保存&amp;退出、搜索&amp;替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write &amp; quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 &gt; 增加窗口宽度 &lt; 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 /etc/vim/vimrc ~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！","categories":[{"name":"linux教程","slug":"linux教程","permalink":"/categories/linux教程/"}],"tags":[{"name":"linux","slug":"linux","permalink":"/tags/linux/"}],"keywords":[{"name":"linux教程","slug":"linux教程","permalink":"/categories/linux教程/"}]},{"title":"C语言提高","slug":"C语言提高","date":"2021-02-03T07:18:43.000Z","updated":"2021-02-03T07:21:05.738Z","comments":true,"path":"2021/02/03/C语言提高/","link":"","permalink":"/2021/02/03/C语言提高/","excerpt":"","text":"C核心编程1 前言1.1 听课要求 专心听讲、积极思考； 遇到不懂的暂时先记下，课后再问； 准备一个笔记本，或者笔记软件（记事本、word、typroa、印象笔记等） 敲代码的时候一定要动手去干，不动手，永远学不会； 杜绝边听边敲、杜绝犯困听课。 如果时间允许，请课前做好预习； 尽量少回看视频，别对视频产生依赖，可以用2倍速度回看视频； 按时完成老师布置的练习，根据自己的理解总结学到的知识点； 初学者 应该抓住重点，不要钻牛角尖遇到问题了，优先自己尝试解决，其次谷歌百度，最后再问老师； 如果时间允许，可以多去网上找对应阶段的学习资料面试题， 注意作息，注意劳逸结合，积极锻炼。 1.2 技术层次 基础 提高 实践 C提高 Qt界面编程 项目1 数据结构 Linux编程 项目2 C++ 数据库编程 项目3 2 内存分区2.1 内存区域C/C++编译的程序占用的内存分为以下几个区域 代码区 全局区/静态区 栈区 堆区 划分： ​ 程序运行前： 代码区、全局区/静态区 ​ 程序运行后：栈区、堆区 2.2 内存四区2.2.1 代码区作用：存放CPU执行的二进制机器指令 特点： 只读 共享 2.2.2 栈区特点： 栈是一种先进后出的内存结构，由编译器自动分配释放数据。 主要存放函数的形式参数值、局部变量等。 函数运行结束，相应栈变量会被自动释放 栈空间较小，不适合将大量数据存放在栈中 总结： 管理方式：编译器自动管理该区内存。空间大小：提前规定、较小。生命周期：函数使用完毕立即释放。 注意事项： 不要返回局部变量的地址 //栈区上开辟的数据由系统进行管理，不需要程序员管理开辟和释放 int * func() { int a = 10; return &amp;a; } //不管结果是否正确，这个值已经被释放了，不可以操作一块非法的内存空间 void test01() { int * p = func(); printf(&quot;a = %d\\n&quot;, *p); printf(&quot;a = %d\\n&quot;, *p); } char * getString() { char str[] = &quot;hello world&quot;; return str; } void test02() { char * p = NULL; p = getString(); printf(&quot;p = %s\\n&quot;, p); } 2.2.3 堆区2.2.3.1 堆区基本概念特点： 堆区由开发人员手动申请和释放，在释放之前，该块堆空间可一直使用。 由程序员分配和释放，若程序员不释放，程序结束时由系统回收内存。 堆空间一般没有软限制，只受限于硬件。会比栈空间更大，适宜存放较大数据。 总结： 管理方式：开发人员手动申请和释放。空间大小：较大。生命周期：手动释放之前一直存在，或程序结束由系统回收。 堆区使用： int * getSpace() { int * p = malloc(sizeof(int)* 5); if (p == NULL) { return; } for (int i = 0; i &lt; 5;i++) { p[i] = i + 100; //所有在连续空间上开辟的数据，都可以利用下标进行索引 } return p; } void test01() { int * p = getSpace(); for (int i = 0; i &lt; 5;i++) { printf(&quot;%d\\n&quot;, p[i]); } //堆区的数据 自己开辟，自己管理释放 free(p); p = NULL; } 2.2.3.2 堆区注意事项注意事项： 主调函数中没有给指针分配内存，被调函数需要利用高级指针进行分屏 分析以下代码运行的结果 void allocateSpace(char * pp) { char * temp = malloc(100); memset(temp, 0, 100); strcpy(temp, &quot;hello world&quot;); pp = temp; } void test02() { char * p = NULL; allocateSpace(p); printf(&quot;%s\\n&quot;, p); } 解决方式1 //利用高级指针 void allocateSpac2(char ** pp) { char * temp = malloc(100); memset(temp, 0, 100); strcpy(temp, &quot;hello world&quot;); *pp = temp; printf(&quot;aaa%s\\n&quot;, *pp); } void test03() { char * p = NULL; allocateSpac2(&amp;p); printf(&quot;%s\\n&quot;, p); } 解决方式2 //利用返回值 char* allocateSpace3() { char *temp = malloc(100); memset(temp, 0, 100); strcpy(temp, &quot;hello world&quot;); return temp; } void test04() { char *p = NULL; p = allocateSpace3(); printf(&quot;%s\\n&quot;, p); } 2.2.3.3 calloc和realloc内存申请我们可使用三个函数来完成，分别为：malloc、calloc、realloc，内存释放我们只需要使用 free 函数。 malloc 函数:原型：void *malloc(unsigned int num_bytes)用法：分配长度为 num_bytes 字节的内存块。说明：如果分配成功则返回指向被分配内存的指针，否则返回 NULL。 calloc 函数:原型：void *calloc(int num_elems, int elem_size)用法：为具有 num_elems 个长度为 elem_size 元素的数组分配内存。说明：如果分配成功则返回指向被分配内存的指针，否则返回 NULL。 realloc 函数:原型：void *realloc(void *mem_address, unsigned int newsize)作用：改变 mem_address 所指内存区域的大小为 newsize 长度。说明：如果重新分配成功则返回指向被分配内存的指针，否则返回 NULL。 free 函数:原型：void free(void *p);作用：释放指针 p 所指向的的内存空间。说明：p所指向的内存空间必须是用 calloc,malloc,realloc 所分配的内存。如果 p 为 NULL则不做任何操作。 calloc案例： //1. calloc void test01() { int *p = calloc(10,sizeof(int)); for (int i = 0; i &lt; 10; ++i) { p[i] = i + 1; } for (int i = 0; i &lt; 10; ++i) { printf(&quot;%d\\n&quot;, p[i]); } if (p != NULL) { free(p); p = NULL; } } realloc案例： void test02() { int *p = malloc(sizeof(int)* 10); for (int i = 0; i &lt; 10; ++i) { p[i] = i + 1; } for (int i = 0; i &lt; 10; ++i) { printf(&quot;%d &quot;, p[i]); } printf(&quot;%d\\n&quot;, p); p = realloc(p, sizeof(int)* 200); printf(&quot;%d\\n&quot;,p); for (int i = 0; i &lt; 15; ++i) { printf(&quot;%d &quot;, p[i]); } } 2.2.4 全局/静态区2.2.4.1 基本概念特点： 全局/静态区存储全局变量、静态变量、常量，该区变量在程序运行期间一直存在 程序结束由系统回收。 已初始化的数据放在data段，未初始化的数据放到bss段 该区变量当未初始化时，会有有默认值初始化。 总结： 管理方式：编译器自动管理该区内存。生命周期：程序结束释放。 2.2.4.2 全局变量//其他文件中声明第二行代码 extern int g_a = 10; //c语言中 默认全局变量前 加了关键字 extern void test01() { extern int g_a; printf(&quot;g_a = %d\\n&quot;, g_a); } extern int g_b; void test02() { printf(&quot;g_b = %d\\n&quot;, g_b); } 2.2.4.3 静态变量void func() { static int s_a = 10; //静态变量只初始化一次 s_a++; printf(&quot;%d\\n&quot;, s_a); } void test03() { func(); func(); func(); } void test04() { static int s_a; //如果未初始化，默认为0 printf(&quot;%d\\n&quot;, s_a); } 2.2.3.4 常量 const修饰的变量 字符串常量 const修饰的变量： //全局常量 const int a = 10; //全局常量存放到常量区，收到常量区的保护 void test01() { //a = 20; //直接修改失败 int * p = &amp;a; *p = 30; //间接修改 语法通过，运行失败 printf(&quot;a = %d &quot;, a); //局部常量 const int b = 10; //b分配到了栈上,可以通过间接方式对其进行修改 //b = 30; //直接修改失败 int * p2 = &amp;b; *p2 = 30; printf(&quot;b = %d\\n&quot;, b); //间接修改成功，C语言下const修饰的局部常量为伪常量 } 结论： ​ 全局修改失败，局部修改成功 字符串常量： //1、字符串常量 是可以共享的 void test01() { char * p1= &quot;hello world&quot;; char * p2 = &quot;hello world&quot;; char * p3 = &quot;hello world&quot;; printf(&quot;%d\\n&quot;,&amp;&quot;hello world&quot;); printf(&quot;%d\\n&quot;, p1); printf(&quot;%d\\n&quot;, p2); printf(&quot;%d\\n&quot;, p3); } //2、vs下 不可以修改字符串常量中的内存 void test02() { char * p1 = &quot;hello world&quot;; printf(&quot;%d\\n&quot;, p1); printf(&quot;%c\\n&quot;, p1[0]); //p1[0] = &#39;W&#39;; //不允许修改 常量区内容 } 上述案例中字符串常量修改失败，但这不是绝对的 ANSI C中规定：修改字符串常量，结果是未定义的 有些编译器把多个相同的字符串常量看成一个（节省空间），有些则不进行此优化 有些编译器可修改字符串常量，有些编译器则不可修改字符串常量 结论： 尽量不要去修改字符串常量 2.3 函数调用模型2.3.1 宏函数宏函数概念： 宏函数和宏常量都是利用#define定义出来的内容 在项目中，经常把一些短小而又频繁使用的函数写成宏函数 这是由于宏函数没有普通函数参数压栈、跳转、返回等时间上的开销，可以调高程序的效率。 注意事项： 宏函数通常需要加括号，保证运算的完整 #define MYADD(x,y) ((x) + (y)) //不是函数 ，宏函数 //普通函数下的a、b都要进行入栈，函数执行后出栈 int myAdd(int a ,int b) { return a + b; } //宏函数 在一定的场景下 要比普通的函数效率高，把频繁使用并且短小的函数 可以写成宏函数 //宏函数在编译阶段就替换源码 //而没有普通函数入栈出栈的开销，以空间换时间 void test01() { int a = 10; int b = 20; printf(&quot;a + b = %d\\n&quot;, MYADD(a, b)); // ((a) + (b)) } 总结：将频繁短小的函数可以封装为宏函数，以空间换时间。 2.3.2 函数调用流程在2.3.1中我们学会了宏函数，其中讲到了普通函数执行的时候会有些时间的开销 下面我通过以下案例来分析下 ，一个简单的函数调用流程 int func(int a,int b){ int t_a = a; int t_b = b; return t_a + t_b; } int main(){ int ret = 0; ret = func(10, 20); return EXIT_SUCCESS; } 通过上面的案例，我们知道一个普通函数的调用流程 在此期间又引出两个问题 被调函数func中的a、b入栈的顺序是从左到右，还是从右到左？ 当被调函数执行完毕后，a、b这两个参数是由主调函数mian去管理释放还是被调函数func管理释放？ 带着这两个问题来看2.3.3 调用惯例 2.3.3 调用惯例调用惯例概念： 函数的调用方（主调函数）和被调用方（）对于函数是如何调用的必须有一个明确的约定， 只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为调用惯例 C/C++语言中存在多个调用惯例，默认使用的调用惯例为 cdecl 注: cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字 调用惯例包含的内容有： 调用惯例 出栈方 参数传递 名字修饰 cdecl 函数调用方 从右至左参数入栈 下划线+函数名 stdcall 函数本身 从右至左参数入栈 下划线+函数名+@+参数字节数 fastcall 函数本身 前两个参数由寄存器传递，后面从右到左 @+函数名+@+参数的字节数 pascal 函数本身 从左至右参数入栈 较为复杂，参见相关文档 2.3.4 栈的生长方向作用：了解栈中元素与元素之间的存储方式 //栈的生长方向 自上而下 ，栈底高地址 栈顶低地址 void test01() { int a = 10; int b = 20; int c = 30; int d = 40; printf(&quot;%d\\n&quot;, &amp;a); printf(&quot;%d\\n&quot;, &amp;b); printf(&quot;%d\\n&quot;, &amp;c); printf(&quot;%d\\n&quot;, &amp;d); } 结论：栈底高地址 栈顶低地址 2.3.5 内存存储方式内存中的多字节数据相对于内存地址有大端和小端之分。 小端模式：==高==位字节数据保存在内存的==高==地址中，==低==位字节数据保存在内存的==低==地址中 大端模式：==高==位字节数据保存在内存的==低==地址中，==低==位字节数据保存在内存的==高==地址中 验证方式： int a = 0x11223344; char * p = &amp;a; //char * 改变指针步长，一次跳一个字节 printf(&quot;%x\\n&quot;, *p); // 44 低地址 -- 低位字节 printf(&quot;%x\\n&quot;, *(p+1)); printf(&quot;%x\\n&quot;, *(p+2)); printf(&quot;%x\\n&quot;, *(p+3)); // 11 高地址 -- 高位字节 3 指针进阶3.1 空指针和野指针3.1.1 空指针​ 含义：特殊的指针变量，表示不指向任何东西 ​ 作用：指针变量创建的时候，可以初始化为NULL ​ 注意：不要对空指针进行解引用操作 3.1.2 野指针​ 含义：野指针指向一个已释放的内存或者未申请过的内存空间 ​ 注意：不要对野指针进行解引用操作 void test01(){ char *p = NULL; //给p指向的内存区域拷贝内容 strcpy(p, &quot;1111&quot;); //err char *q = 0x1122; //给q指向的内存区域拷贝内容 strcpy(q, &quot;2222&quot;); //err } 3.1.3 常见的野指针 指针变量为初始化 释放堆区的指针后未置空 指针操作超越了变量作用域 int* func() { int a = 10; int * p = &amp;a; return p; } void test02() { //1 指针变量未初始化 int * p1; //printf(&quot;%d\\n&quot;, *p1); //2 指针释放后未置空 int * p2 = (int*)malloc(sizeof(int)); *p2 = 100; free(p2); printf(&quot;%d\\n&quot;, *p2); //乱码 已经释放了 //3 指针操作超越变量作用域 int * p3 = func(); printf(&quot;%d\\n&quot;, *p3); } 注意： 空指针可以free，但是野指针不可以 3.2 指针步长的意义作用：清楚不同类型的指针有何不同的意义 指针变量+1后跳跃字节数量不同 解引用的时候，取出字节数量不同 void test01() { char * p = NULL; printf(&quot;%d\\n&quot;, p); printf(&quot;%d\\n&quot;, p+1); int * p1 = NULL; printf(&quot;%d\\n&quot;, p1); printf(&quot;%d\\n&quot;, p1 + 1); } //2、解引用时候 取多少字节数 void test02() { char buf[1024] = { 0 }; //1024字节 int a = 1000; //4字节 memcpy(buf+1, &amp;a, sizeof(int)); char * p = buf; printf(&quot;%d\\n&quot;, *(int*)(p+1) ); } 练习：在下面结构体中利用地址偏移，找到结构体中d属性的位置以及打印该属性 struct Person { char a; 0 ~ 3 int b; 4 ~ 7 char buf[64]; 8 ~ 71 int d; 72 ~ 75 }; void test03() { struct Person p = { &#39;A&#39;, 10, &quot;hello world&quot;, 10000 }; //自定义数据类型找偏移量 可以通过函数寻找 printf(&quot;%d\\n&quot;, offsetof(struct Person, d));//#include &lt;stddef.h&gt; //打印d的数字 printf(&quot;d = %d\\n&quot;, *(int*)((char *)&amp;p + offsetof(struct Person, d))); } 3.3 指针的间接赋值变量的修改方式有两种：直接修改、间接修改 通过指针可以进行间接赋值，间接赋值成立的条件为： 两个变量（普通变量+指针变量） / (实参+形参) 建立关系 通过*操作指针指向的内存 void changeValue(int *p) { *p = 1000; } void test01() { //1 、一个普通变量 和一个指针变量 构成指针的间接赋值 int a = 10; int * p = &amp;a; *p = 100; printf(&quot;a = %d\\n&quot;, a); //2、通过实参和形参 进行间接赋值 int a2 = 0; changeValue(&amp;a2); printf(&quot;a2 = %d\\n&quot;, a2); } 思考：如果我们可以提前知道变量的地址编号，是否也可以修改内存空间？ 3.4 指针做函数参数输入输出特性输入特性：主调函数分配内存，被调函数使用 输出特性：被调函数分配内存，主调函数使用 3.4.1 输入特性//栈区分配 void fun(char *p) { //给p指向的内存区域拷贝内容 strcpy(p, &quot;helloabcde&quot;); } void test02(void) { //栈上分配内存 //输入，主调函数分配内存 char buf[1024] = { 0 }; fun(buf); printf(&quot;buf = %s\\n&quot;, buf); } //堆区分配 void printString(char * str) { printf(&quot;%s\\n&quot;, str); } void test01() { //堆区分配内存 char * p = malloc(sizeof(char)* 64); memset(p, 0, 64); strcpy(p, &quot;hello world&quot;); printString(p); } 3.4.2 输出特性void allocteSpace( char ** p) { char * tempP = malloc(sizeof(char)* 64); memset(tempP, 0, 64); strcpy(tempP, &quot;hello world!!!&quot;); *p = tempP; } void test03() { char *p = NULL; allocteSpace(&amp;p); printf(&quot;%s\\n&quot;, p); if (p!=NULL) { free(p); } p = NULL; } 3.5 指针易错点3.5.1 指针越界void test01(){ char buf[8] = &quot;zhangtao&quot;; printf(&quot;buf:%s\\n&quot;,buf); } 3.5.2 返回局部变量地址char *getString() { char str[] = &quot;abcdedsgads&quot;; //栈区， printf(&quot;getString - str = %s\\n&quot;, str); return str; } void test02() { char * str = getString(); printf(&quot;test - str = %s\\n&quot;, str); } 3.5.3 同一块内存释放多次void test03() { char *p = malloc(sizeof(char) * 64); free(p); free(p); } 3.5.4 释放偏移后的指针void test04() { char str[] = &quot;hello world&quot;; char *p = malloc(64); for (int i = 0; i &lt;= strlen(str); i++) { *p = str[i]; ++p; } free(p); } 3.6 二级指针输出输出特性3.6.1 二级指针输入特性void printArray(int **arr , int len) { for (int i = 0; i &lt; 5;i++) { printf(&quot;数组中第%d个元素的值为%d \\n&quot;, i + 1, *arr[i]); //值 } } //堆区开辟空间 void test01() { int ** pArray = malloc(sizeof(int *)* 5); //在栈中分配数据 int a1 = 100; int a2 = 200; int a3 = 300; int a4 = 400; int a5 = 500; pArray[0] = &amp;a1; pArray[1] = &amp;a2; pArray[2] = &amp;a3; pArray[3] = &amp;a4; pArray[4] = &amp;a5; int len = 5; printArray(pArray, len); //释放堆区空间 if (pArray != NULL) { free(pArray); pArray = NULL; } } //在栈上开辟空间 void test02() { int * pArray[5]; //开辟到栈中 for (int i = 0; i &lt; 5;i++) { pArray[i] = malloc(4); *(pArray[i]) = i + 100; } printArray(pArray, 5); //释放堆区空间 for (int i = 0; i &lt; 5;i++) { if (pArray[i] != NULL) { free(pArray[i]); pArray[i] = NULL; } } } 3.6.2 二级指针输出特性void allocateSpace(int ** p) { int *arr = malloc(sizeof(int)* 10); for (int i = 0; i &lt; 10;i++) { arr[i] = i; } *p = arr; } void printArray(int ** arr, int len) { for (int i = 0; i &lt; len;i++) { printf(&quot;%d\\n&quot;, (*arr)[i]); } } void freeSpace(int ** arr) { if (*arr!=NULL) { free(*arr); *arr = NULL; } } void test01() { int * p = NULL; allocateSpace(&amp;p); printArray(&amp;p, 10); freeSpace(&amp;p); if (p == NULL) { printf(&quot;数组指针已经置空\\n&quot;); } } 4 位运算4.1 数据的存储方式4.1.1 printf格式化输出作用：利用printf输出不同进制下的数字 void test01() { int a = 10; printf(&quot;十进制：%d\\n&quot;, a); printf(&quot;八进制：%#o\\n&quot;, a); printf(&quot;十六进制：%#x\\n&quot;, a); printf(&quot;十六进制：%#X\\n&quot;, a); } void test02() { int a = 123; //十进制方式赋值 int b = 0123; //八进制方式赋值， 以数字0开头 int c = 0xabc; //十六进制方式赋值 printf(&quot;十进制：%d\\n&quot;, a); printf(&quot;八进制：%#o\\n&quot;, b); //%o,为字母o,不是数字 printf(&quot;十六进制：%#x\\n&quot;, c); } 4.1.2 存储方式4.1.2.1存数据在计算机中，数据有三种表现形式，分别为：原码、反码、补码 原码：最高位为符号位，0代表正，1代表负 反码：无符号或正数，原码 = 反码；负数反码 = 原码符号位不变，其余为取反 补码：无符号或正数，原码 = 反码； 负数补码 = 反码+1 注：计算机存放数据都是用补码形式 总结： 无符号数以及有符号数的正数 源码 = 反码 = 补码 符号数 负数 反码 = 原码 取反（不包括符号位） 补码 = 反码 + 1 4.4.2.2 补码意义 统一了零的编码 十进制数 原码 +0 0000 0000 -0 1000 0000 十进制数 反码 +0 0000 0000 -0 1111 1111 十进制数 补码 +0 0000 0000 -0 10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000 将减法运算转变为加法运算 例如： 9 - 6 十进制数 原码 9 0000 1001 -6 1000 0110 如果用原码计算： 0000 1001 1000 0100 + 1000 1111 结果： 9 - 6 = -15不正确 利用补码进行计算 十进制数 补码 9 0000 1001 -6 1111 1010 0000 1001 1111 1010 + 10000 0011 最高位的1溢出，剩余8位二进制表示为3，结果正确 4.1.2.3 取数据 无符号取数据： %u %lu %llu %o %x … 有符号取数据： %d %ld %lld %f %llf … 取数据步骤： 高位如果是0， 代表正数 原码 = 反码 = 补码 ，原样输出 高位如果是1， 代表负数 符号位不变，其余位取反 + 1 注：程序中的八进制和十六进制的数据，不用考虑正负，按照无符号对待 相关案例： void test01() { char num = -15; //原码 1000 1111 //反码 1111 0001 //补码 1111 1010 //有符号输出 printf(&quot;%d\\n&quot;, num); //无符号输出 printf(&quot;%u\\n&quot;, num &amp; 0x000000ff); //编译器自动让结果与 前3个字节为1 的数字 做了按位或操作 /* 0000 0000 0000 0000 0000 0000 1111 0001 反码 1111 1111 1111 1111 1111 1111 0000 0000 | 1111 1111 1111 1111 1111 1111 1111 0001 结果 */ } void test02() { char num = 0x9b; // 这个就是 1001 1011 就是补码 //计算机原样存储 // 有符号取 // 补码 1001 1011 // 原码 1110 0101 -（64 + 32 + 4 + 1） = - 101 printf(&quot;%d\\n&quot;, num); //无符号取 printf(&quot;%x\\n&quot;, num &amp; 0x000000ff); //9b printf(&quot;%u\\n&quot;, num &amp; 0x000000ff); // 128 + 16 + 8 + 2 + 1 = 155 } 4.2 位运算4.2.1 位运算符 按位取反 ==~==，对每个二进制位进行取反，0变1,1变0 位与 ==&amp;==， 同真为真，其余为假 位或 ==|==， 同假为假，其余为真 位抑或 ==^==，相同为假，不同为真 //1. 按位取反 ~ void test01() { int number = 2; printf(&quot;~number : %d\\n&quot;, ~number); int num = -2; printf(&quot;%d\\n&quot;, ~num); } //2. 位与 &amp; void test02() { int number = 332; if ((number &amp; 1) == 0) { printf(&quot;%d是偶数!\\n&quot;,number); } else { printf(&quot;%d是奇数!\\n&quot;,number); } //number = number &amp; 0; number &amp;= 0; printf(&quot;number:%d\\n&quot;, number); } //3. 位或 | void test03() { int num1 = 5; int num2 = 3; printf(&quot;num1 | num2 = %d\\n&quot;, num1 | num2); } //4 位抑或 ^ void test04() { int num1 = 5; int num2 = 10; printf(&quot;num1:%d num2:%d\\n&quot;, num1, num2); num1 = num1 ^ num2; num2 = num1 ^ num2; num1 = num1 ^ num2; printf(&quot;num1:%d num2:%d\\n&quot;,num1,num2); } 4.2.2 移位运算符 左移 &lt;&lt;，按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补 0。 右移 &gt;&gt;，按二进制形式把所有的数字向右移动对应位移位数，低位移出(舍弃)，高位的空位补符号位 //左移运算符 左移几位就相当于乘以2的几次方 void test05() { int number = 20; printf(&quot;number = %d\\n&quot;, number &lt;&lt;= 2); printf(&quot;number = %d\\n&quot;, number &gt;&gt;= 1); } 注： 右移运算，对于无符号数据，高位用0填补，有符号正数用0，负数有些计算机系统用0，有些用1，不是绝对 5 数组进阶5.1 一维数组与数组名数组定义：一片连续内存空间里，放相同类型的数据元素 思考：一维数组的数组名是不是指向数组中第一个元素的指针？ void printArray( int arr[] , int len) // int arr[] ==== int * arr 前者可读性高 { for (int i = 0; i &lt; len;i++) { printf(&quot;%d\\n&quot;, arr[i]); } } void test01() { int arr[5] = { 1, 2, 3, 4, 5 }; //1、当sizeof数组名时候，统计是整个数组的大小 printf(&quot;sizeof(arr) = %d\\n&quot;, sizeof(arr)); //2、当对数组名 取地址的时候 printf(&quot;%d\\n&quot;, &amp;arr); printf(&quot;%d\\n&quot;, &amp;arr + 1); //除了以上两种情况外 ， 数组名都指向数组中的首地址 int * p = arr; // 直接对int*p进行赋值，也不会报错 //数组名 是个指针常量 //arr = NULL; int len = sizeof(arr) / sizeof(int); printArray(arr, len); //数组下标是否可以为负数? p = p + 3; printf(&quot;p[-1] = %d\\n&quot;, p[-1]); //上述代码等价于 printf(&quot;p[-1] = %d\\n&quot;, *(p-1) ); } 结论： 一维数组数组名除了两种特殊情况外，可以理解为指向第一个元素的指针 特殊情况： sizeof数组名 对数组名取地址 5.2 数组指针定义方式数组指针的定义方式： 先定义出数组的类型，再定义数组指针变量 先定义数组指针的类型，再定义数组指针变量 直接定义数组指针变量 //1、先定义出数组的类型，再定义数组指针变量 void test01() { int arr[] = { 1, 2, 3, 4, 5 }; typedef int(ARRAY_TYPE)[5]; //ARRAY_TYPE是一个数据类型，存放5个int元素的数组的类型 ARRAY_TYPE * arrP = &amp;arr; //arrP就是数组指针 // *arrP 是 arr for (int i = 0; i &lt; 5;i++) { //printf(&quot;%d\\n&quot;, (*arrP)[i]); printf(&quot;%d\\n&quot;, *((*arrP)+i) ); } } //2、先定义数组指针的类型，再定义数组指针变量 void test02() { int arr[] = { 1, 2, 3, 4, 5 }; typedef int(*ARRAY_TYPE)[5]; // *arrP 是 arr ARRAY_TYPE arrP = &amp;arr; for (int i = 0; i &lt; 5; i++) { printf(&quot;%d\\n&quot;, (*arrP)[i]); printf(&quot;%d\\n&quot;, *((*arrP) + i)); } } //3、直接定义数组指针变量 void test03() { int arr[] = { 1, 2, 3, 4, 5 }; int(*p)[5] = &amp;arr; //*p -&gt; arr for (int i = 0; i &lt; 5; i++) { printf(&quot;%d\\n&quot;, (*p)[i]); } } 5.3 二维数组与数组名知道一维数组数组名的意义后，我们应该能够推到出二维数组数组名的意义了 void test01() { int arr[3][3] = { {1,2,3}, {4,5,6}, {7,8,9} }; //int arr2[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //int arr3[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; //二维数组名 等价与 一维数组的指针 //除了对二维数组名 sizeof 或者 取地址以外，那么二维数组名 都是指向第一个一维数组的首地址 int(*pArray)[3] = arr; //通过数组名 访问元素 printf(&quot;arr[1][2] = %d\\n&quot;, arr[1][2]); printf(&quot;arr[1][2] = %d\\n&quot;, *(*(pArray + 1) + 2)); printf(&quot;arr[1][2] = %d\\n&quot;, *(*pArray + 5)); } //二维数组做函数参数 //void printArray( int(*pArr)[3] ,int len1,int len2 ) //void printArray(int pArr[3][3], int len1, int len2) void printArray(int pArr[][3], int len1, int len2) { for (int i = 0; i &lt; len1;i++) { for (int j = 0; j &lt; len2;j++) { //printf(&quot;%d &quot;, pArr[i][j]); printf(&quot;%d &quot;, *(*(pArr + i) + j) ); } printf(&quot;\\n&quot;);; } } void test02() { int arr[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; int row = sizeof(arr)/sizeof(arr[0]); int col = sizeof(arr[0]) / sizeof(int); printArray(arr, 3, 3); } 6 结构体进阶6.1 结构体基本使用结构体作用：内置数据类型不够用的时候，我们可以利用结构体创建自定义的数据类型 下面案例中可以看出结构体的基本使用 struct Person { char name[64]; int age; //不要给自定义数据类型赋初始值，因为只是在做定义 自定义数据类型 }; typedef struct Person myPerson; typedef struct Person1 { char name[64]; int age; }myPerson; //给类型起别名 void test01() { myPerson p1 = {&quot;aaa&quot;,10}; } //在定义结构体的时候 顺便定义了一个结构体变量 struct Person2 { char name[64]; int age; }person2 = {&quot;bbb&quot;,40}; //如果是变量 可以给初始化 void test02() { person2.age = 20; strcpy(person2.name, &quot;bbb&quot;); } struct { char name[64]; int age; }person3 = {&quot;ddd&quot;,100}; //定义一个结构体变量 person3，后面无法使用这个类型，而这个类型只有一个变量 void test03() { person3.age = 30; strcpy(person3.name, &quot;ccc&quot;); } //结构体使用 struct Person { char name[64]; int age; //不要给自定义数据类型赋初始值，因为只是在做定义 自定义数据类型 }; void test04() { //在栈上使用 struct Person p1 = { &quot;aaa&quot;, 10 }; printf(&quot;p1 姓名： %s , 年龄: %d \\n&quot;, p1.name, p1.age); //在堆区使用 struct Person * p2 = malloc(sizeof(struct Person)); p2-&gt;age = 20; strcpy(p2-&gt;name, &quot;bbb&quot;); printf(&quot;p2 姓名： %s , 年龄: %d \\n&quot;, p2-&gt;name, p2-&gt;age); free(p2); p2 = NULL; } void printPerson( struct Person personArr[], int len) { for (int i = 0; i &lt; len;i++) { printf(&quot;姓名： %s , 年龄: %d \\n&quot;, personArr[i].name, personArr[i].age); } } //结构体变量数组 void test05() { //栈上分配内存 struct Person persons[] = { { &quot;aaa&quot;, 10 }, { &quot;bbb&quot;, 20 }, { &quot;ccc&quot;, 30 }, { &quot;ddd&quot;, 40 }, }; int len = sizeof(persons) / sizeof(struct Person); printPerson(persons, len); //堆区分配内存 struct Person * personPoint = malloc(sizeof(struct Person) * 4); for (int i = 0; i &lt; 4;i++) { sprintf(personPoint[i].name, &quot;name_%d&quot;, i); personPoint[i].age = i + 10; } printPerson(personPoint, 4); free(personPoint); personPoint = NULL; } 6.2 结构体赋值问题以及解决这设计到一个深浅拷贝的问题 6.2.1 结构体不包含指针的情况struct Person { char name[64]; int age; }; void test01() { struct Person p1 = { &quot;Tom&quot;, 18 }; struct Person p2 = { &quot;Jerry&quot;, 20 }; p1 = p2; //逐字节的进行拷贝 printf(&quot;P1 姓名 ： %s, 年龄： %d\\n&quot;, p1.name, p1.age); printf(&quot;P2 姓名 ： %s, 年龄： %d\\n&quot;, p2.name, p2.age); } 6.2.2 结构体包含指针的情况 struct Person2 { char * name; int age; }; void test02() { struct Person2 p1; p1.name = malloc(sizeof(char)* 64); strcpy(p1.name, &quot;Tom&quot;); p1.age = 18; struct Person2 p2; p2.name = malloc(sizeof(char)* 128); strcpy(p2.name, &quot;Jerry&quot;); p2.age = 20; //赋值 //p1 = p2; //解决方式 手动进行赋值操作 /////////////////////////////////// if (p1.name!=NULL) { free(p1.name); p1.name = NULL; } p1.name = malloc(strlen(p2.name) + 1); strcpy(p1.name, p2.name); p1.age = p2.age; //////////////////////////////////// printf(&quot;P1 姓名 ： %s 年龄： %d\\n&quot;, p1.name, p1.age); printf(&quot;P2 姓名 ： %s, 年龄： %d\\n&quot;, p2.name, p2.age); //堆区开辟的内容 自己管理释放 if (p1.name != NULL) { free(p1.name); p1.name = NULL; } if (p2.name != NULL) { free(p2.name); p2.name = NULL; } } 总结：当结构体中包含堆区的指针，要利用深拷贝解决浅拷贝的问题 6.3 结构体偏移量意义：能够计算出结构体中属性相对于首地址的偏移量 案例： #include &lt;stddef.h&gt; struct Teacher { char a; int b; }; void test01(){ struct Teacher t1; struct Teacher*p = &amp;t1; int offsize1 = (int)&amp;(p-&gt;b) - (int)p; //通过地址查看成员b 相对于结构体 Teacher的偏移量 int offsize2 = offsetof(struct Teacher, b);//通过宏函数查看 printf(&quot;offsize1:%d \\n&quot;, offsize1); //打印b属性对于首地址的偏移量 printf(&quot;offsize2:%d \\n&quot;, offsize2); } //通过偏移量 打印成员数据 void test02() { struct Teacher t = { &#39;a&#39;, 10 }; //打印c2的数据 printf(&quot;t.b = %d\\n&quot;, *(int *)((char*)&amp;a + offsetof(struct Teacher, b))); printf(&quot;t.b = %d\\n&quot;, *(int*)((int *)&amp;a + 1 )); } //结构体嵌套结构体 计算偏移量方法 struct Teacher2 { char a; int b; struct Teacher c; }; void test03() { struct Teacher2 t = { &#39;a&#39;, 10, &#39;b&#39;, 20 }; int offset1 = offsetof(struct Teacher2, c); int offset2 = offsetof(struct Teacher, b); printf(&quot;%d\\n&quot;, *(int *)(((char*)&amp;t + offset1) + offset2)); printf(&quot;%d\\n&quot;, ((struct Teacher2 *)((char *)&amp;t + offset1))-&gt;b); } 6.4 内存对齐6.4.1 内存对齐意义内存的最小单元是一个字节 CPU实际上将内存当成多个块，每次从内存中读取一个块，这个块的大小可能是2、4、8、16等， 我们来分析下非内存对齐和内存对齐的优缺点在哪？ 如果没有对齐，为了访问一个变量可能产生二次访问。 有了内存对齐，可以提高操作系统访问内存的效率。 6.4.2 结构体对齐计算规则 第一个属性 从偏移量0位置开始存储 第二个属性开始，放在 min(该类型的大小 ,对齐模数) 的整数倍上 整体计算完毕后算总大小，结构体总大小必须是 min(该结构体中最大数据类型 ,对齐模数) 整数倍,不足要补齐 #pragma pack(show)可以查看对齐模数 练习： struct Student{ int a; char b; double c; float d; }; void test01() { printf(&quot;sizeof = %d\\n&quot;, sizeof(struct Student)); } //2、结构体嵌套结构体， 按照子结构体最大的类型计算 struct Student2 { char a; struct Student b; double c; }; void test02() { printf(&quot;sizeof = %d\\n&quot;, sizeof(struct Student2)); } 7 文件读写7.1 文件基本概念7.1.1 文件的基本概念数据源的一种，最主要的作用是保存数据，如word、txt、头文件、源文件、exe等 7.1.2 文件的分类文件可以分为 磁盘文件 设备文件 磁盘文件： 磁盘文件是计算机里的文件。存储信息不受断电的影响，存取速度相对于内存慢得多了 设备文件： 操作系统中把每一个与主机相连的输入、输出设备看作是一个文件 例如 显示器称为标准输出文件, 键盘称为标准输入文件 7.1.3 磁盘文件的分类计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。 从用户或操作系统的角度，将文件分为： 文本文件 二进制文件 文本文件： 基于字符编码，常见的编码有ASCII、UNICODE等 一般可以使用文本编辑器直接打开 如数字5678的存储形式 (ASCII码)为： 00110101 00110110 00110111 00111000 二进制文件： 基于值编码,自己根据具体应用,指定某个值是什么意思 把内存中的数据按其在内存中的存储形式原样输出到磁盘上 如数5678的存储形式(二进制码)为：00010110 00101110 7.2 文件指针在C语言中，操作文件之前必须先打开文件；所谓“打开文件”，就是让程序和文件建立连接的过程。 打开文件之后，程序可以得到文件的相关信息，例如大小、类型、权限、创建者、更新时间等。 操作系统为了操作文件，提供了一堆文件的操作函数，而函数通过文件指针识别不同的文件 文件指针如下： typedef struct { short level; //缓冲区&quot;满&quot;或者&quot;空&quot;的程度 unsigned flags; //文件状态标志 char fd; //文件描述符 unsigned char hold; //如无缓冲区不读取字符 short bsize; //缓冲区的大小 unsigned char *buffer;//数据缓冲区的位置 unsigned ar; //指针，当前的指向 unsigned istemp; //临时文件，指示器 short token; //用于有效性的检查 }FILE; FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型 总结：如果我们想利用C语言操作一个文件，首先要获取到文件指针 7.3 文件打开与关闭7.3.1 fopen函数函数原型： FILE *fopen(char *filename, char *mode); 功能：打开文件 参数： ​ filename - 需要打开的文件名，根据需要加上路径 ​ mode - 打开文件的模式设置 返回值： 成功：文件指针 ​ 失败：NULL 打开模式 含义 r或rb 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） w或wb 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a或ab 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件 r+或rb+ 以可读、可写的方式打开文件(不创建新文件) w+或wb+ 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) a+或ab+ 以添加方式打开文件，打开文件并在末尾更改文件,若文件不存在则创建文件 注：b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的 7.3.2 fclose函数函数原型：int fclose(FILE *fp); 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭 7.3.3 文件打开关闭案例void test01() { FILE *fp = NULL; fp = fopen(&quot;a.txt&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;打开失败\\n&quot;); return; } printf(&quot;打开成功\\n&quot;); fclose(fp); } 7.4 文件读写7.4.1 按字符方式读写写文件 fputc ​ 函数原型： int fputc(int ch, FILE *stream) 读文件 fgetc ​ 函数原型：int fgetc(FILE * stream) 案例： void test01() { //打开文件 FILE *fp = NULL; fp = fopen(&quot;a.txt&quot;, &quot;w&quot;); if (fp == NULL) { printf(&quot;打开失败\\n&quot;); return; } //操作文件 char buf[] = &quot;hello world\\n&quot;; int i = 0; while (buf[i] != 0) { fputc(buf[i], fp); i++; } //关闭文件 fclose(fp); } void test02() { //打开文件 FILE *fp = NULL; fp = fopen(&quot;a.txt&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;打开失败\\n&quot;); return; } //操作文件 char ch = 0; while( (ch = fgetc(fp)) != EOF ) { printf(&quot;ch = %c\\n&quot;, ch); } //关闭文件 fclose(fp); } 注：==EOF==为文件结束标志，可以用来判断文件是否读取到文件尾 7.4.2 按行方式读写写文件 fputs ​ 函数原型： int fputs(const char *str, FILE *stream) 读文件 fgets ​ 函数原型：int fgets(char *str, int size, FILE *stream) 案例： void test01() { char *buf[] = { &quot;床前明月光\\n&quot;, &quot;疑似地上霜\\n&quot;, &quot;举头望明月\\n&quot;, &quot;低头思故乡\\n&quot; }; FILE *fp = NULL; fp = fopen(&quot;a.txt&quot;, &quot;w&quot;); if (fp == NULL) { printf(&quot;打开失败\\n&quot;); return; } for (int i = 0; i &lt; sizeof(buf) / sizeof(buf[0]); i++) { fputs(buf[i], fp); } fclose(fp); } void test02() { FILE *fp = NULL; fp = fopen(&quot;a.txt&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;打开失败\\n&quot;); return; } char buf[1024] = { 0 }; while (!feof(fp)){ char temp[1024] = { 0 }; fgets(buf, 1024, fp); if(feof(file_read)) { break; } temp[strlen(buf)-1] = &#39;\\0&#39;; printf(&quot;%s&quot;, buf); } fclose(fp); } 注： feof函数可以判断文件是否读取到了文件尾。如果是返回的值是1（真），否则为0（假） 使用 feof 常用的逻辑结构是先读在判断 7.4.3 按格式化方式读写写文件 fprintf ​ 函数原型： int fprintf(FILE * stream, const char * format, ...); 读文件 fscanf ​ 函数原型：int fscanf(FILE * stream, const char * format, ...); 案例： //格式化读写 struct Hero { char name[16]; int atk; int def; }; void test01() { struct Hero hero[5] = { { &quot;亚瑟&quot;,110, 200 }, { &quot;赵云&quot;,150, 150 }, { &quot;韩信&quot;,170, 130 }, { &quot;蔡文姬&quot;,100, 180 }, { &quot;斧头帮帮主&quot;,999, 999 } }; FILE *fp = fopen(&quot;test1.txt&quot;, &quot;w&quot;); if (fp == NULL) { printf(&quot;文件打开失败\\n&quot;); return; } for (int i = 0; i &lt; sizeof(hero) / sizeof(struct Hero); i++) { //1个中文两个字节 int len = fprintf(fp, &quot;%s %d %d\\n&quot;, hero[i].name, hero[i].atk, hero[i].def); printf(&quot;第%d行写入字节数：%d\\n&quot;,i+1, len);//返回写入字符数 } fclose(fp); } void test02() { struct Hero hero[5]; memset(hero, 0, sizeof(hero)); FILE *fp = fopen(&quot;test1.txt&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;文件打开失败\\n&quot;); return; } int i = 0; while (!feof(fp)) { fscanf(fp, &quot;%s %d %d\\n&quot;, hero[i].name, &amp;hero[i].atk, &amp;hero[i].def); i++; } int n = i; for (int i = 0; i &lt; n; i++) { printf(&quot;name = %s atk = %d def = %d\\n&quot;, hero[i].name, hero[i].atk, hero[i].def); } fclose(fp); } 7.4.4 按块方式读写写文件 fprintf ​ 函数原型： size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);; 读文件 fscanf ​ 函数原型： size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 案例： //块读写回顾 struct Hero{ char name[64]; int age; }; void test01(){ //写文件 FILE* file_write = NULL; //写方式打开文件 file_write = fopen(&quot;./test3.txt&quot;, &quot;wb&quot;); //wb 二进制方式写 if (file_write == NULL){ return; } struct Hero heros[4] = { { &quot;孙悟空&quot;, 33 }, { &quot;韩信&quot;, 28 }, { &quot;赵云&quot;, 45 }, { &quot;亚瑟&quot;, 35 } }; for (int i = 0; i &lt; 4; i++){ //参数1 数据地址 参数2 块大小 参数3 块数 参数4 文件指针 fwrite(&amp;teachers[i], sizeof(struct Hero), 1, file_write); } //关闭文件 fclose(file_write); } void test02() { //读文件 FILE* fp_read = NULL; fp_read = fopen(&quot;./test3.txt&quot;, &quot;rb&quot;); //二进制方式读 if (fp_read == NULL){ return; } struct Hero temps[4]; fread(&amp;temps, sizeof(struct Hero), 4, fp_read); for (int i = 0; i &lt; 4; i++){ printf(&quot;Name:%s\\t Age:%d\\n&quot;, temps[i].name, temps[i].age); } fclose(fp_read); } 7.5 文件指针移动文件指针移动这里主要介绍3个函数 rewind fseek ftell 7.5.1 rewind函数原型：void rewind(FILE *stream ); 功能：把文件流（文件光标）的读写位置移动到文件开头 7.5.2 fseek函数原型： int fseek(FILE *stream, long offset, int fromwhere); 功能：移动文件流（文件光标）的读写位置。 fromwhere：取值如下： ​ SEEK_SET：从文件开头移动offset个字节 ​ SEEK_CUR：从当前位置移动offset个字节 ​ SEEK_END：从文件末尾移动offset个字节 fseek相关案例： struct Hero{ char name[64]; int age; }; void test01(){ //写文件 FILE* file_write = NULL; //写方式打开文件 file_write = fopen(&quot;./test4.txt&quot;, &quot;wb&quot;); //wb 二进制方式写 if (file_write == NULL){ return; } struct Hero heros[4] = { { &quot;孙悟空&quot;, 33 }, { &quot;韩信&quot;, 28 }, { &quot;赵云&quot;, 45 }, { &quot;亚瑟&quot;, 35 } }; for (int i = 0; i &lt; 4; i++){ //参数1 数据地址 参数2 块大小 参数3 块数 参数4 文件指针 fwrite(&amp;teachers[i], sizeof(struct Hero), 1, file_write); } //关闭文件 fclose(file_write); //随机位置读取 FILE* file_read = NULL; file_read = fopen(&quot;./test4.txt&quot;, &quot;rb&quot;); if (file_read == NULL){ return; } //创建临时的结构体 struct Hero temp; //读文件 移动到第三个结构体位置 fseek(file_read, sizeof(Heros)* 2, SEEK_SET); //SEEK_SET从文件开始移动 fread(&amp;temp, sizeof(Heros), 1, file_read); printf(&quot;Name:%s Age:%d\\n&quot;, temp.name, temp.age); memset(&amp;temp, 0, sizeof(Heros)); fseek(file_read, -(long)sizeof(Heros)* 2, SEEK_END); //SEEK_END从文件末尾移动 fread(&amp;temp, sizeof(Heros), 1, file_read); printf(&quot;Name:%s Age:%d\\n&quot;, temp.name, temp.age); rewind(file_read); //把文件流（文件光标）的读写位置移动到文件开头，读第一个结构体 fread(&amp;temp, sizeof(Heros), 1, file_read); printf(&quot;Name:%s Age:%d\\n&quot;, temp.name, temp.age); fclose(file_read); } 7.5.3 ftell函数原型：long ftell(FILE *stream); 功能： 获取文件流（文件光标）的读写位置 ftell相关案例 void test03() { FILE *fp = fopen(&quot;test1.txt&quot;, &quot;w&quot;); fputs(&quot;hello,斧头帮帮主&quot;, fp); fclose(fp); fp = fopen(&quot;test1.txt&quot;, &quot;r&quot;); //将文件流指针定位到文件尾部 fseek(fp, 0, SEEK_END); //得到文件流指针的偏移量 int len = ftell(fp); printf(&quot;len = %d\\n&quot;, len); fclose(fp); } 7.6 文件相关案例解析配置文件案例 案例需求： 游戏中有个配置文件，其中带$开头的代表注释信息，以:分隔的为正文内容 : 左侧的起到索引作用，称为key值 : 右侧的起到实值作用，称为value 将数据进行解析，并以键值对形式维护每组数据 创建一个数组，维护所有的键值对结构体 提供一个函数，可以通过key返回对应的value值 提示: 键值对的结构体设计可以如下 struct ConfigInfo { char key[64]; char value[64]; }; 配置文件config.txt 内容如下： $英雄的Id heroId:1 $英雄的姓名 heroName:琦玉 $英雄的攻击力 heroAtk:99999 $英雄的防御力 heroDef:99999 $英雄的简介 heroInfo:无敌 8 函数指针8.1 函数指针概念函数指针：函数名称就是函数的入口地址，我们可以通过函数指针去指向函数的入口地址 void func() { printf(&quot;hello world\\n&quot;); } int main() { printf(&quot;%p\\n&quot;, func); system(&quot;pause&quot;); return EXIT_SUCCESS; } 8.2 函数指针定义方式函数指针定义方式有三种： 先定义函数类型，通过函数类型定义函数指针变量 先定义函数指针类型，再通过函数指针类型定义函数指针变量 直接定义函数指针变量 代码如下： void func(int a ,char b) { printf(&quot;hello world\\n&quot;); } void test01() { //1、先定义函数类型，通过函数类型定义函数指针变量 typedef void(FUNC_TYPE)(int,char); FUNC_TYPE * pFunc = func; pFunc(10,&#39;a&#39;); //2、先定义函数指针类型，再通过函数指针类型定义函数指针变量 typedef void(*FUNC_TYPE2) (int, char); FUNC_TYPE2 pFunc2 = func; pFunc2(10, &#39;a&#39;); //3、直接定义函数指针变量 void(*pFunc3)(int, char) = func; pFunc3(10, &#39;a&#39;); //4、函数指针 和 指针函数区别 //函数指针是指向函数的指针； //指针函数是返回类型为指针的函数； } //函数指针的数组 void func1() { printf(&quot;func1调用\\n&quot;); } void func2() { printf(&quot;func2调用\\n&quot;); } void func3() { printf(&quot;func3调用\\n&quot;); } void test02() { //函数指针数组 void(*fun_array[3])(); fun_array[0] = func1; fun_array[1] = func2; fun_array[2] = func3; for (int i = 0; i &lt; 3;i++) { fun_array[i](); } } 8.3 回调函数案例当函数指针做函数参数的时候，利用函数指针调用所指的函数时，称为回调函数 案例1 ：提供一个函数，实现可以打印任何类型的元素 void printText(void * data, void(*func)(void *)) { func(data); } void myPrintInt(void * data) //参数就是每个元素的地址 { int * num = data; printf(&quot;%d\\n&quot;, *num); } void test01() { int a = 10; printText(&amp;a,myPrintInt); } struct Person { char name[64]; int age; }; void myPrintPerson(void * data) //参数就是每个元素的地址 { struct Person * p = data; printf(&quot;姓名：%s 年龄： %d \\n&quot;, p-&gt;name,p-&gt;age); } void test02() { struct Person p = { &quot;Tom&quot;, 100 }; printText(&amp;p, myPrintPerson); } 案例2 ：提供一个函数，可以打印任意类型的数组 void printALLArray(void *arr, int eleSize, int len , void(*myFunc)(void *) ) { char * p = arr; for (int i = 0; i &lt; len;i++) { char * eleAddr = p + eleSize* i; //计算每个元素的地址 myFunc(eleAddr); } } void myPrintInt(void * data) { int * num = data; printf(&quot;%d\\n&quot;, *num); } struct Person { char name[64]; int age; }; void myPrintPerson(void * data) { struct Person * p = data; printf(&quot;姓名： %s 年龄： %d \\n&quot;, p-&gt;name, p-&gt;age); } void test01() { int arr[] = { 1, 2, 3, 4, 5 }; int len = sizeof(arr) / sizeof(int); printALLArray(arr, sizeof(int), len, myPrintInt); struct Person personArr[] = { { &quot;aaa&quot;, 10 }, { &quot;bbb&quot;, 20 }, { &quot;ccc&quot;, 30 }, { &quot;ddd&quot;, 40 } }; len = sizeof(personArr)/ sizeof(struct Person); printALLArray(personArr, sizeof(struct Person), len, myPrintPerson); } 案例3 ：查找数组中的元素是否存在 int findArrayEle(void *arr, int eleSize, int len, int(*myFunc)(void * , void *) , void * data) { char * p = arr; for (int i = 0; i &lt; len; i++) { char * eleAddr = p + eleSize* i; //计算每个元素的地址 if (myFunc(eleAddr , data)) { return 1; } } return 0; } int myFindPerson(void * data1, void * data2) { struct Person * p1 = data1; struct Person * p2 = data2; if (strcmp(p1-&gt;name,p2-&gt;name) == 0 &amp;&amp; p1-&gt;age == p2-&gt;age ) { return 1; } return 0; } void test02() { struct Person personArr[] = { { &quot;aaa&quot;, 10 }, { &quot;bbb&quot;, 20 }, { &quot;ccc&quot;, 30 }, { &quot;ddd&quot;, 40 } }; int len = sizeof(personArr) / sizeof(struct Person); struct Person p = { &quot;aaa&quot;, 10 }; int ret = findArrayEle(personArr, sizeof(struct Person), len, myFindPerson , &amp;p); if (ret) { printf(&quot;找到了！\\n&quot;); } else { printf(&quot;未找到!\\n&quot;); } } 9 预处理指令9.1 预处理概念 预处理是在程序源代码被编译之前，由预处理器对程序源代码进行的处理。 这个阶段并不对程序的源代码语法进行解析，为下一步的编译做准备工作。 9.2 文件包含指令 文件包含是指一个源文件可以将另外一个文件的全部内容包含进来。 Ｃ语言提供了#include命令用来实现“文件包含”的操作 图示： #incude&lt;&gt; #include””区别 &lt; &gt; 表示包含系统头文件 &quot; &quot; 表示包含自定义头文件 9.3 宏定义9.3.1 宏常量语法： #define 名称 值 实例： #define MAX 1024 void test(){ double r = 10.0; double s = PI * r * r; printf(&quot;s = %lf\\n&quot;, s); } 总结： 宏名一般用大写，以便于与变量区别 宏定义可以是常数(宏常量)、表达式（宏函数） 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错 宏名从定义到本源文件结束都可以使用 可以用#undef命令终止宏定义的作用域 9.3.2 宏函数语法： #define 宏函数名(参数) 表达式 实例： define SUM(x,y) (( x )+( y )) #define SUM(x,y) (( x )+( y )) void test(){ int ret = SUM(10, 20); printf(&quot;ret:%d\\n&quot;,ret); } 总结： 在项目中，可以把一些短小而又频繁使用的函数写成宏函数 宏函数没有普通函数参数压栈、出栈上的开销，可以调高程序的效率 宏的名字中不能有空格，但是在替换的字符串中可以有空格 用括号括住每一个参数，并括住宏的整体定义。 用大写字母表示宏的函数名。 ​ 9.4 条件编译 一般情况下，源程序中所有的行都参加编译 但有时希望对部分源程序行只在满足一定条件时才编译，即对这部分源程序行指定编译条件 条件编译三种使用： 测试存在 #ifdef 测试不存在 #ifndef 自定义条件 #if 示例： #ifdef #define debug #ifdef debug void func1() { printf(&quot;Debug版本\\n&quot;); } #else void func1() { printf(&quot;Release版本\\n&quot;); } #endif #ifndef //防止头文件被重复包含引用； #ifndef _SOMEFILE_H #define _SOMEFILE_H ... #endif #if //做注释用 #if 0 void myAdd() { printf(&quot;第一种写法\\n&quot;); } #else void myAdd() { printf(&quot;第二种写法\\n&quot;); } #endif 9.5 特殊宏// __FILE__ 宏所在文件的源文件名 // __LINE__ 宏所在行的行号 // __DATE__ 代码编译的日期 // __TIME__ 代码编译的时间 void test() { printf(&quot;%s\\n&quot;, __FILE__); printf(&quot;%d\\n&quot;, __LINE__); printf(&quot;%s\\n&quot;, __DATE__); printf(&quot;%s\\n&quot;, __TIME__); } 10 动态库的配置与使用10.1 库的基本概念 库是已经写好的、成熟的、可复用的代码 每个程序都需要依赖很多底层库，不可能每个人的代码从零开始编写代码 我们的开发的应用中经常有一些公共代码是需要反复使用的，就把这些代码编译为库文件。 库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成的一个文件。 10.2 静态库的配置与使用window下静态库配置步骤如下： 创建新项目，编写库文件 修改项目配置属性 生成库文件 测试并使用库 具体流程如下： 1 创建项目 创建一个空项目，项目名称例如：静态库 创建头文件和头文件，例如staticLib.h和staticLib.c 头文件添加如下代码： #pragma once //加法运算，实现两个整型数字相加，并返回结果 int myadd(int a, int b); 源文件添加如下代码： #include &quot;staticLib.h&quot; int myadd(int a, int b) { return a + b; } 2 修改项目配置属性 右键项目点击属性 在属性页面中选择 配置属性 - 常规 -配置类型 - 静态库 - 确定 3 生成库文件 此时，不需要运行程序，这里也没有写程序的入口 点击生成菜单，选择生成项目即可 成功后，在staticLib.c的==上层==的Debug目录中会有静态库.lib文件 注： 通常将生成的.lib文件和.h文件交给用户 .h本身不需要，但是只有lib文件用户看不懂里面内容 .h中写的库函数功能尽量描述清晰，起到说明作用 4 测试并使用库 创建新项目，导入生成的.lib和.h文件导入到项目中进行测试 运行查看结果，成功实现后，会打印出1 + 1 = 2 10.3 动态库的配置与使用10.3.1 静态库优缺点本章节主要讲的内容是动态库，主要是因为静态库缺点明显，利小于弊 优点： 静态库在程序的链接阶段被复制到了程序中 程序在运行时与库再无瓜葛，移植方便 缺点： 浪费空间和资源 静态库所有内容都放在了程序中 假设1个程序占用1MB，如果磁盘中有2000个程序，将近浪费了2GB空间 更新部署麻烦 假设库文件为第三方厂商提供 如果库文件有所改动，需要更新，那么整个程序需要重新编译发布给用户 用户也需要重新安装整个程序 10.3.2 动态库简介为了解决静态库浪费空间和更新困难的两个问题，诞生了动态库 动态库链接思想： 将整个链接过程推迟到运行时候在进行 程序中用到了库函数，再从库中使用 更新时候，只需要替换库文件 10.3.3 动态库配置和使用window下动态库配置步骤如下： 创建新项目，编写库文件 修改项目配置属性 生成库文件 测试并使用库 具体流程如下： 1 创建项目 创建一个空项目，项目名称例如：动态库 创建头文件和头文件，例如dynamicLib.h和dynamicLib.c 头文件添加如下代码： #pragma once //减法运算，实现两个整型数字相减，并返回结果 __declspec(dllexport) int mysub(int a, int b); 注： __declspec(dllexport) 为导出函数，只有导出函数才可以被外部程序使用 源文件添加如下代码： #include &quot;dynamicLib.h&quot; int mysub(int a, int b) { return a - b; } 2 修改项目配置属性 右键项目点击属性 在属性页面中选择 配置属性 - 常规 -配置类型 - 动态库 - 确定 3 生成库文件 不需要运行程序，点击生成菜单，选择生成项目即可 成功后，在staticLib.c的==上层==的Debug目录中会有核心文件：动态库.lib 文件 以及 动态库.dll文件 注： 通常将生成的.dll文件 .lib文件和.h文件交给用户 .h中写的库函数功能尽量描述清晰，起到说明作用 本案例演示库程序为中文，实际开发中最好用英文 动态库中的lib文件中存放导出函数的声明，具体实现在dll中，这与静态库中的lib是不同的 4 测试并使用库 创建新项目，导入生成的.dll 、 .lib和 .h文件导入到项目中进行测试 运行查看结果，成功实现后，会打印出1 - 1 = -1 注： 如果不把文件导入项目中，也可以采用代码中添加 #pragma comment(lib,&quot;./动态库.lib&quot;) 使用动态库 11 递归函数11.1 普通函数调用学习递归函数前，我们先要搞清楚普通函数的调用流程 #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; void funB(int a) { printf(&quot;funB中的 a = %d\\n&quot;, a); } void funA(int a) { funB(a - 1); printf(&quot;funA中的 a = %d\\n&quot;, a); } int main() { funA(2); printf(&quot;main\\n&quot;); system(&quot;pause&quot;); return EXIT_SUCCESS; } 思考上面代码运行的结果，理解代码的执行流程 流程分析图： 执行结果为： funcB中的 a = 1; funcA中的 a = 2; main 请按任意键继续... 11.2 递归函数调用如果11.1已经看懂，那么接下来分析以下代码的运行结果： #define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; void funA(int a) { if (a == 1) { printf(&quot;funA中的 a = %d\\n&quot;, a); return; } funA(a - 1); printf(&quot;funA中的 a = %d\\n&quot;, a); } int main() { funA(2); printf(&quot;main\\n&quot;); system(&quot;pause&quot;); return EXIT_SUCCESS; } 流程分析图： 执行结果为： funcA中的 a = 1; funcA中的 a = 2; main 请按任意键继续... 上面这种，在函数中调用自身，就属于递归函数 注： 递归函数必须有退出条件，否则出现无限递归 11.3 递归函数案例案例1：逆序遍历字符串 void reversePrint(char * p) { if (*p == &#39;\\0&#39;) { return; } reversePrint(p + 1); printf(&quot;%c&quot;, *p); } void test01() { char * str = &quot;abcdefgh&quot;; reversePrint(str); } 案例2：获取斐波那契数列指定位置元素 斐波那契数列：1、1、2、3、5、8… int fibonacci(int pos) { if (pos == 1 || pos == 2) { return 1; } return fibonacci(pos - 1) + fibonacci(pos - 2); } void test02() { int num = fibonacci(10); printf(&quot;斐波那契数列中第十个元素为：%d\\n&quot;, num); }","categories":[{"name":"C编程笔记","slug":"C编程笔记","permalink":"/categories/C编程笔记/"}],"tags":[{"name":"编程","slug":"编程","permalink":"/tags/编程/"},{"name":"C","slug":"C","permalink":"/tags/C/"}],"keywords":[{"name":"C编程笔记","slug":"C编程笔记","permalink":"/categories/C编程笔记/"}]},{"title":"机房预约系统","slug":"机房预约系统","date":"2021-02-03T07:13:06.000Z","updated":"2021-02-03T07:21:05.737Z","comments":true,"path":"2021/02/03/机房预约系统/","link":"","permalink":"/2021/02/03/机房预约系统/","excerpt":"","text":"机房预约系统1、机房预约系统需求1.1 系统简介 学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套机房预约系统，解决这一问题。 1.2 身份简介分别有三种身份使用该程序 学生代表：申请使用机房 教师：审核学生的预约申请 管理员：给学生、教师创建账号 1.3 机房简介机房总共有3间 1号机房 — 最大容量20人 2号机房 — 最多容量50人 3号机房 — 最多容量100人 1.4 申请简介 申请的订单每周由管理员负责清空。 学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午） 教师来审核预约，依据实际情况审核预约通过或者不通过 1.5 系统具体需求 首先进入登录界面，可选登录身份有： 学生代表 老师 管理员 退出 每个身份都需要进行验证后，进入子菜单 学生需要输入 ：学号、姓名、登录密码 老师需要输入：职工号、姓名、登录密码 管理员需要输入：管理员姓名、登录密码 学生具体功能 申请预约 — 预约机房 查看自身的预约 — 查看自己的预约状态 查看所有预约 — 查看全部预约信息以及预约状态 取消预约 — 取消自身的预约，预约成功或审核中的预约均可取消 注销登录 — 退出登录 教师具体功能 查看所有预约 — 查看全部预约信息以及预约状态 审核预约 — 对学生的预约进行审核 注销登录 — 退出登录 管理员具体功能 添加账号 — 添加学生或教师的账号，需要检测学生编号或教师职工号是否重复 查看账号 — 可以选择查看学生或教师的全部信息 查看机房 — 查看所有机房的信息 清空预约 — 清空所有预约记录 注销登录 — 退出登录 2、创建项目创建项目步骤如下： 创建新项目 添加文件 2.1 创建项目 打开vs2017后，点击创建新项目，创建新的C++项目 如图： 填写项目名称以及选取项目路径，点击确定生成项目 2.2 添加文件 右键源文件，进行添加文件操作 填写文件名称，点击添加 生成文件成功，效果如下图 3、创建主菜单功能描述： 设计主菜单，与用户进行交互 3.1 菜单实现 在主函数main中添加菜单提示，代码如下： int main() { cout &lt;&lt; &quot;====================== 欢迎来到传智播客机房预约系统 =====================&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;请输入您的身份&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t\\t -------------------------------\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 1.学生代表 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 2.老 师 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 3.管 理 员 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 0.退 出 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t -------------------------------\\n&quot;; cout &lt;&lt; &quot;输入您的选择: &quot;; system(&quot;pause&quot;); return 0; } 运行效果如图： 3.2 搭建接口 接受用户的选择，搭建接口 在main中添加代码 int main() { int select = 0; while (true) { cout &lt;&lt; &quot;====================== 欢迎来到传智播客机房预约系统 =====================&quot; &lt;&lt; endl; cout &lt;&lt; endl &lt;&lt; &quot;请输入您的身份&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t\\t -------------------------------\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 1.学生代表 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 2.老 师 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 3.管 理 员 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 0.退 出 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t -------------------------------\\n&quot;; cout &lt;&lt; &quot;输入您的选择: &quot;; cin &gt;&gt; select; //接受用户选择 switch (select) { case 1: //学生身份 break; case 2: //老师身份 break; case 3: //管理员身份 break; case 0: //退出系统 break; default: cout &lt;&lt; &quot;输入有误，请重新选择！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); break; } } system(&quot;pause&quot;); return 0; } 测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择 效果如图： 至此，界面搭建完毕 4、 退出功能实现4.1 退出功能实现在main函数分支 0 选项中，添加退出程序的代码： cout &lt;&lt; &quot;欢迎下一次使用&quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0; 4.2 测试退出功能运行程序，效果如图： 至此，退出程序功能实现 5、 创建身份类5.1 身份的基类 在整个系统中，有三种身份，分别为：学生代表、老师以及管理员 三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类identity 在头文件下创建Identity.h文件 Identity.h中添加如下代码： #pragma once #include&lt;iostream&gt; using namespace std; //身份抽象类 class Identity { public: //操作菜单 virtual void operMenu() = 0; string m_Name; //用户名 string m_Pwd; //密码 }; 效果如图： 5.2 学生类5.2.1 功能分析 学生类主要功能是可以通过类中成员函数，实现预约实验室操作 学生类中主要功能有： 显示学生操作的菜单界面 申请预约 查看自身预约 查看所有预约 取消预约 ​ 5.2.2 类的创建 在头文件以及源文件下创建 student.h 和 student.cpp文件 student.h中添加如下代码： #pragma once #include&lt;iostream&gt; using namespace std; #include &quot;identity.h&quot; //学生类 class Student :public Identity { public: //默认构造 Student(); //有参构造(学号、姓名、密码) Student(int id, string name, string pwd); //菜单界面 virtual void operMenu(); //申请预约 void applyOrder(); //查看我的预约 void showMyOrder(); //查看所有预约 void showAllOrder(); //取消预约 void cancelOrder(); //学生学号 int m_Id; }; student.cpp中添加如下代码： #include &quot;student.h&quot; //默认构造 Student::Student() { } //有参构造(学号、姓名、密码) Student::Student(int id, string name, string pwd) { } //菜单界面 void Student::operMenu() { } //申请预约 void Student::applyOrder() { } //查看我的预约 void Student::showMyOrder() { } //查看所有预约 void Student::showAllOrder() { } //取消预约 void Student::cancelOrder() { } 5.3 老师类5.3.1 功能分析 教师类主要功能是查看学生的预约，并进行审核 教师类中主要功能有： 显示教师操作的菜单界面 查看所有预约 审核预约 ​ 5.3.2 类的创建 在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件 teacher.h中添加如下代码： #pragma once #define _CRT_SECURE_NO_WARNINGS #include&lt;iostream&gt; using namespace std; #include &quot;identity.h&quot; class Teacher :public Identity { public: //默认构造 Teacher(); //有参构造 (职工编号，姓名，密码) Teacher(int empId, string name, string pwd); //菜单界面 virtual void operMenu(); //查看所有预约 void showAllOrder(); //审核预约 void validOrder(); int m_EmpId; //教师编号 }; teacher.cpp中添加如下代码: #include&quot;teacher.h&quot; //默认构造 Teacher::Teacher() { } //有参构造 (职工编号，姓名，密码) Teacher::Teacher(int empId, string name, string pwd) { } //菜单界面 void Teacher::operMenu() { } //查看所有预约 void Teacher::showAllOrder() { } //审核预约 void Teacher::validOrder() { } 5.4 管理员类5.4.1 功能分析 管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录 管理员类中主要功能有： 显示管理员操作的菜单界面 添加账号 查看账号 查看机房信息 清空预约记录 ​ 5.4.2 类的创建 在头文件以及源文件下创建 manager.h 和 manager.cpp文件 manager.h中添加如下代码： #pragma once #include&lt;iostream&gt; using namespace std; #include &quot;identity.h&quot; class Manager :public Identity { public: //默认构造 Manager(); //有参构造 管理员姓名，密码 Manager(string name, string pwd); //选择菜单 virtual void operMenu(); //添加账号 void addPerson(); //查看账号 void showPerson(); //查看机房信息 void showComputer(); //清空预约记录 void cleanFile(); }; manager.cpp中添加如下代码: #include &quot;manager.h&quot; //默认构造 Manager::Manager() { } //有参构造 Manager::Manager(string name, string pwd) { } //选择菜单 void Manager::operMenu() { } //添加账号 void Manager::addPerson() { } //查看账号 void Manager::showPerson() { } //查看机房信息 void Manager::showComputer() { } //清空预约记录 void Manager::cleanFile() { } 至此，所有身份类创建完毕，效果如图： 6、 登录模块6.1 全局文件添加功能描述： 不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中 在头文件中添加 globalFile.h 文件 并添加如下代码： #pragma once //管理员文件 #define ADMIN_FILE &quot;admin.txt&quot; //学生文件 #define STUDENT_FILE &quot;student.txt&quot; //教师文件 #define TEACHER_FILE &quot;teacher.txt&quot; //机房信息文件 #define COMPUTER_FILE &quot;computerRoom.txt&quot; //订单文件 #define ORDER_FILE &quot;order.txt&quot; 并且在同级目录下，创建这几个文件 6.2 登录函数封装功能描述： 根据用户的选择，进入不同的身份登录 在预约系统的.cpp文件中添加全局函数 void LoginIn(string fileName, int type) 参数： fileName — 操作的文件名 type — 登录的身份 （1代表学生、2代表老师、3代表管理员） LoginIn中添加如下代码： #include &quot;globalFile.h&quot; #include &quot;identity.h&quot; #include &lt;fstream&gt; #include &lt;string&gt; //登录功能 void LoginIn(string fileName, int type) { Identity * person = NULL; ifstream ifs; ifs.open(fileName, ios::in); //文件不存在情况 if (!ifs.is_open()) { cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl; ifs.close(); return; } int id = 0; string name; string pwd; if (type == 1) //学生登录 { cout &lt;&lt; &quot;请输入你的学号&quot; &lt;&lt; endl; cin &gt;&gt; id; } else if (type == 2) //教师登录 { cout &lt;&lt; &quot;请输入你的职工号&quot; &lt;&lt; endl; cin &gt;&gt; id; } cout &lt;&lt; &quot;请输入用户名：&quot; &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入密码： &quot; &lt;&lt; endl; cin &gt;&gt; pwd; if (type == 1) { //学生登录验证 } else if (type == 2) { //教师登录验证 } else if(type == 3) { //管理员登录验证 } cout &lt;&lt; &quot;验证登录失败!&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } 在main函数的不同分支中，填入不同的登录接口 6.3 学生登录实现在student.txt文件中添加两条学生信息，用于测试 添加信息: 1 张三 123 2 李四 123456 其中： 第一列 代表 学号 第二列 代表 学生姓名 第三列 代表 密码 效果图： 在Login函数的学生分支中加入如下代码，验证学生身份 //学生登录验证 int fId; string fName; string fPwd; while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd) { if (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd) { cout &lt;&lt; &quot;学生验证登录成功!&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); person = new Student(id, name, pwd); return; } } 添加代码效果图 测试： 6.4 教师登录实现在teacher.txt文件中添加一条老师信息，用于测试 添加信息: 1 老王 123 其中： 第一列 代表 教师职工编号 第二列 代表 教师姓名 第三列 代表 密码 效果图： 在Login函数的教师分支中加入如下代码，验证教师身份 //教师登录验证 int fId; string fName; string fPwd; while (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd) { if (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd) { cout &lt;&lt; &quot;教师验证登录成功!&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); person = new Teacher(id, name, pwd); return; } } 添加代码效果图 测试： 6.5 管理员登录实现在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能 添加信息: admin 123 其中：admin代表管理员用户名，123代表管理员密码 效果图： 在Login函数的管理员分支中加入如下代码，验证管理员身份 //管理员登录验证 string fName; string fPwd; while (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd) { if (name == fName &amp;&amp; pwd == fPwd) { cout &lt;&lt; &quot;验证登录成功!&quot; &lt;&lt; endl; //登录成功后，按任意键进入管理员界面 system(&quot;pause&quot;); system(&quot;cls&quot;); //创建管理员对象 person = new Manager(name,pwd); return; } } 添加效果如图： 测试效果如图： 至此，所有身份的登录功能全部实现！ 7、 管理员模块7.1 管理员登录和注销7.1.1 构造函数 在Manager类的构造函数中，初始化管理员信息，代码如下： //有参构造 Manager::Manager(string name, string pwd) { this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; } 7.1.2 管理员子菜单 在机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口 将不同的分支提供出来 添加账号 查看账号 查看机房 清空预约 注销登录 实现注销功能 添加全局函数 void managerMenu(Identity * &amp;manager)，代码如下： //管理员菜单 void managerMenu(Identity * &amp;manager) { while (true) { //管理员菜单 manager-&gt;operMenu(); Manager* man = (Manager*)manager; int select = 0; cin &gt;&gt; select; if (select == 1) //添加账号 { cout &lt;&lt; &quot;添加账号&quot; &lt;&lt; endl; man-&gt;addPerson(); } else if (select == 2) //查看账号 { cout &lt;&lt; &quot;查看账号&quot; &lt;&lt; endl; man-&gt;showPerson(); } else if (select == 3) //查看机房 { cout &lt;&lt; &quot;查看机房&quot; &lt;&lt; endl; man-&gt;showComputer(); } else if (select == 4) //清空预约 { cout &lt;&lt; &quot;清空预约&quot; &lt;&lt; endl; man-&gt;cleanFile(); } else { delete manager; cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } } } 7.1.3 菜单功能实现 在实现成员函数void Manager::operMenu() 代码如下： //选择菜单 void Manager::operMenu() { cout &lt;&lt; &quot;欢迎管理员：&quot;&lt;&lt;this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t\\t ---------------------------------\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 1.添加账号 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 2.查看账号 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 3.查看机房 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 4.清空预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 0.注销登录 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t ---------------------------------\\n&quot;; cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl; } 7.1.4 接口对接 管理员成功登录后，调用管理员子菜单界面 在管理员登录验证分支中，添加代码： //进入管理员子菜单 managerMenu(person); 添加效果如： 测试对接，效果如图： 登录成功 注销登录： 至此，管理员身份可以成功登录以及注销 7.2 添加账号功能描述： 给学生或教师添加新的账号 功能要求： 添加时学生学号不能重复、教师职工号不能重复 7.2.1 添加功能实现在Manager的addPerson成员函数中，实现添加新账号功能，代码如下： //添加账号 void Manager::addPerson() { cout &lt;&lt; &quot;请输入添加账号的类型&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、添加学生&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、添加老师&quot; &lt;&lt; endl; string fileName; string tip; ofstream ofs; int select = 0; cin &gt;&gt; select; if (select == 1) { fileName = STUDENT_FILE; tip = &quot;请输入学号： &quot;; } else { fileName = TEACHER_FILE; tip = &quot;请输入职工编号：&quot;; } ofs.open(fileName, ios::out | ios::app); int id; string name; string pwd; cout &lt;&lt;tip &lt;&lt; endl; cin &gt;&gt; id; cout &lt;&lt; &quot;请输入姓名： &quot; &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入密码： &quot; &lt;&lt; endl; cin &gt;&gt; pwd; ofs &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; pwd &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); ofs.close(); } 测试添加学生： 成功在学生文件中添加了一条信息 测试添加教师： 成功在教师文件中添加了一条信息 7.2.2 去重操作功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误 7.2.2.1 读取信息 要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测 在manager.h中，添加两个容器，用于存放学生和教师的信息 添加一个新的成员函数 void initVector() 初始化容器 //初始化容器 void initVector(); //学生容器 vector&lt;Student&gt; vStu; //教师容器 vector&lt;Teacher&gt; vTea; 添加位置如图： 在Manager的有参构造函数中，获取目前的学生和教师信息 代码如下： void Manager::initVector() { //读取学生文件中信息 ifstream ifs; ifs.open(STUDENT_FILE, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件读取失败&quot; &lt;&lt; endl; return; } vStu.clear(); vTea.clear(); Student s; while (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp; ifs &gt;&gt; s.m_Pwd) { vStu.push_back(s); } cout &lt;&lt; &quot;当前学生数量为： &quot; &lt;&lt; vStu.size() &lt;&lt; endl; ifs.close(); //学生初始化 //读取老师文件信息 ifs.open(TEACHER_FILE, ios::in); Teacher t; while (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp; ifs &gt;&gt; t.m_Pwd) { vTea.push_back(t); } cout &lt;&lt; &quot;当前教师数量为： &quot; &lt;&lt; vTea.size() &lt;&lt; endl; ifs.close(); } 在有参构造函数中，调用初始化容器函数 //有参构造 Manager::Manager(string name, string pwd) { this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; //初始化容器 this-&gt;initVector(); } 测试，运行代码可以看到测试代码获取当前学生和教师数量 7.2.2.2 去重函数封装在manager.h文件中添加成员函数bool checkRepeat(int id, int type); //检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复) bool checkRepeat(int id, int type); 在manager.cpp文件中实现成员函数 bool checkRepeat(int id, int type); bool Manager::checkRepeat(int id, int type) { if (type == 1) { for (vector&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++) { if (id == it-&gt;m_Id) { return true; } } } else { for (vector&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++) { if (id == it-&gt;m_EmpId) { return true; } } } return false; } 7.2.2.3 添加去重操作在添加学生编号或者教师职工号时，检测是否有重复，代码如下： string errorTip; //重复错误提示 if (select == 1) { fileName = STUDENT_FILE; tip = &quot;请输入学号： &quot;; errorTip = &quot;学号重复，请重新输入&quot;; } else { fileName = TEACHER_FILE; tip = &quot;请输入职工编号：&quot;; errorTip = &quot;职工号重复，请重新输入&quot;; } ofs.open(fileName, ios::out | ios::app); int id; string name; string pwd; cout &lt;&lt;tip &lt;&lt; endl; while (true) { cin &gt;&gt; id; bool ret = this-&gt;checkRepeat(id, 1); if (ret) //有重复 { cout &lt;&lt; errorTip &lt;&lt; endl; } else { break; } } 代码位置如图： 检测效果： 7.2.2.4 bug解决bug描述： 虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测 导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复 解决方案： 在每次添加新账号时，重新初始化容器 在添加完毕后，加入代码： //初始化容器 this-&gt;initVector(); 位置如图： 再次测试，刚加入的账号不会重复添加了！ 7.3 显示账号功能描述：显示学生信息或教师信息 7.3.1 显示功能实现在Manager的showPerson成员函数中，实现显示账号功能，代码如下： void printStudent(Student &amp; s) { cout &lt;&lt; &quot;学号： &quot; &lt;&lt; s.m_Id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; s.m_Name &lt;&lt; &quot; 密码：&quot; &lt;&lt; s.m_Pwd &lt;&lt; endl; } void printTeacher(Teacher &amp; t) { cout &lt;&lt; &quot;职工号： &quot; &lt;&lt; t.m_EmpId &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t.m_Name &lt;&lt; &quot; 密码：&quot; &lt;&lt; t.m_Pwd &lt;&lt; endl; } void Manager::showPerson() { cout &lt;&lt; &quot;请选择查看内容：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、查看所有学生&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、查看所有老师&quot; &lt;&lt; endl; int select = 0; cin &gt;&gt; select; if (select == 1) { cout &lt;&lt; &quot;所有学生信息如下： &quot; &lt;&lt; endl; for_each(vStu.begin(), vStu.end(), printStudent); } else { cout &lt;&lt; &quot;所有老师信息如下： &quot; &lt;&lt; endl; for_each(vTea.begin(), vTea.end(), printTeacher); } system(&quot;pause&quot;); system(&quot;cls&quot;); } 7.3.2 测试测试查看学生效果 测试查看教师效果 至此，显示账号功能实现完毕 7.4 查看机房7.4.1 添加机房信息案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台 我们可以将信息录入到computerRoom.txt中 7.4.2 机房类创建在头文件下，创建新的文件 computerRoom.h 并添加如下代码： #pragma once #include&lt;iostream&gt; using namespace std; //机房类 class ComputerRoom { public: int m_ComId; //机房id号 int m_MaxNum; //机房最大容量 }; 7.4.3 初始化机房信息在Manager管理员类下，添加机房的容器,用于保存机房信息 //机房容器 vector&lt;ComputerRoom&gt; vCom; 在Manager有参构造函数中，追加如下代码，初始化机房信息 //获取机房信息 ifstream ifs; ifs.open(COMPUTER_FILE, ios::in); ComputerRoom c; while (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum) { vCom.push_back(c); } cout &lt;&lt; &quot;当前机房数量为： &quot; &lt;&lt; vCom.size() &lt;&lt; endl; ifs.close(); 位置如图： 因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护 7.4.4 显示机房信息在Manager类的showComputer成员函数中添加如下代码： //查看机房信息 void Manager::showComputer() { cout &lt;&lt; &quot;机房信息如下： &quot; &lt;&lt; endl; for (vector&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end(); it++) { cout &lt;&lt; &quot;机房编号： &quot; &lt;&lt; it-&gt;m_ComId &lt;&lt; &quot; 机房最大容量： &quot; &lt;&lt; it-&gt;m_MaxNum &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 测试显示机房信息功能： 7.5 清空预约功能描述： 清空生成的order.txt预约文件 7.5.1 清空功能实现在Manager的cleanFile成员函数中添加如下代码： //清空预约记录 void Manager::cleanFile() { ofstream ofs(ORDER_FILE, ios::trunc); ofs.close(); cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); } 测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净 8、 学生模块8.1 学生登录和注销8.1.1 构造函数 在Student类的构造函数中，初始化学生信息，代码如下： //有参构造(学号、姓名、密码) Student::Student(int id, string name, string pwd) { //初始化属性 this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; } 8.1.2 管理员子菜单 在机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口 将不同的分支提供出来 申请预约 查看我的预约 查看所有预约 取消预约 注销登录 实现注销功能 添加全局函数 void studentMenu(Identity * &amp;manager) 代码如下： //学生菜单 void studentMenu(Identity * &amp;student) { while (true) { //学生菜单 student-&gt;operMenu(); Student* stu = (Student*)student; int select = 0; cin &gt;&gt; select; if (select == 1) //申请预约 { stu-&gt;applyOrder(); } else if (select == 2) //查看自身预约 { stu-&gt;showMyOrder(); } else if (select == 3) //查看所有预约 { stu-&gt;showAllOrder(); } else if (select == 4) //取消预约 { stu-&gt;cancelOrder(); } else { delete student; cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } } } 8.1.3 菜单功能实现 在实现成员函数void Student::operMenu() 代码如下： //菜单界面 void Student::operMenu() { cout &lt;&lt; &quot;欢迎学生代表：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t\\t ----------------------------------\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 1.申请预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 2.查看我的预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 3.查看所有预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 4.取消预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 0.注销登录 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t ----------------------------------\\n&quot;; cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl; } 8.1.4 接口对接 学生成功登录后，调用学生的子菜单界面 在学生登录分支中，添加代码： //进入学生子菜单 studentMenu(person); 添加效果如图： 测试对接，效果如图： 登录验证通过： 学生子菜单： 注销登录： 8.2 申请预约8.2.1 获取机房信息 在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息 在student.h中添加新的成员函数如下： //机房容器 vector&lt;ComputerRoom&gt; vCom; 在学生的有参构造函数中追加如下代码： //获取机房信息 ifstream ifs; ifs.open(COMPUTER_FILE, ios::in); ComputerRoom c; while (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum) { vCom.push_back(c); } ifs.close(); 追加位置如图： 至此，vCom容器中保存了所有机房的信息 8.2.2 预约功能实现在student.cpp中实现成员函数 void Student::applyOrder() //申请预约 void Student::applyOrder() { cout &lt;&lt; &quot;机房开放时间为周一至周五！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入申请预约的时间：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、周一&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、周二&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、周三&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4、周四&quot; &lt;&lt; endl; cout &lt;&lt; &quot;5、周五&quot; &lt;&lt; endl; int date = 0; int interval = 0; int room = 0; while (true) { cin &gt;&gt; date; if (date &gt;= 1 &amp;&amp; date &lt;= 5) { break; } cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; } cout &lt;&lt; &quot;请输入申请预约的时间段：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、上午&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、下午&quot; &lt;&lt; endl; while (true) { cin &gt;&gt; interval; if (interval &gt;= 1 &amp;&amp; interval &lt;= 2) { break; } cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; } cout &lt;&lt; &quot;请选择机房：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1号机房容量：&quot; &lt;&lt; vCom[0].m_MaxNum &lt;&lt; endl; cout &lt;&lt; &quot;2号机房容量：&quot; &lt;&lt; vCom[1].m_MaxNum &lt;&lt; endl; cout &lt;&lt; &quot;3号机房容量：&quot; &lt;&lt; vCom[2].m_MaxNum &lt;&lt; endl; while (true) { cin &gt;&gt; room; if (room &gt;= 1 &amp;&amp; room &lt;= 3) { break; } cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; } cout &lt;&lt; &quot;预约成功！审核中&quot; &lt;&lt; endl; ofstream ofs(ORDER_FILE, ios::app); ofs &lt;&lt; &quot;date:&quot; &lt;&lt; date &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;interval:&quot; &lt;&lt; interval &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;stuId:&quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;stuName:&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;roomId:&quot; &lt;&lt; room &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;status:&quot; &lt;&lt; 1 &lt;&lt; endl; ofs.close(); system(&quot;pause&quot;); system(&quot;cls&quot;); } 运行程序，测试代码: 在order.txt文件中生成如下内容： 8.3 显示预约8.3.1 创建预约类功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新 在头文件以及源文件下分别创建orderFile.h 和 orderFile.cpp文件 orderFile.h中添加如下代码： #pragma once #include&lt;iostream&gt; using namespace std; #include &lt;map&gt; #include &quot;globalFile.h&quot; class OrderFile { public: //构造函数 OrderFile(); //更新预约记录 void updateOrder(); //记录的容器 key --- 记录的条数 value --- 具体记录的键值对信息 map&lt;int, map&lt;string, string&gt;&gt; m_orderData; //预约记录条数 int m_Size; }; 构造函数中获取所有信息，并存放在容器中，添加如下代码： OrderFile::OrderFile() { ifstream ifs; ifs.open(ORDER_FILE, ios::in); string date; //日期 string interval; //时间段 string stuId; //学生编号 string stuName; //学生姓名 string roomId; //机房编号 string status; //预约状态 this-&gt;m_Size = 0; //预约记录个数 while (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp; ifs &gt;&gt; status) { //测试代码 /* cout &lt;&lt; date &lt;&lt; endl; cout &lt;&lt; interval &lt;&lt; endl; cout &lt;&lt; stuId &lt;&lt; endl; cout &lt;&lt; stuName &lt;&lt; endl; cout &lt;&lt; roomId &lt;&lt; endl; cout &lt;&lt; status &lt;&lt; endl; */ string key; string value; map&lt;string, string&gt; m; int pos = date.find(&quot;:&quot;); if (pos != -1) { key = date.substr(0, pos); value = date.substr(pos + 1, date.size() - pos -1); m.insert(make_pair(key, value)); } pos = interval.find(&quot;:&quot;); if (pos != -1) { key = interval.substr(0, pos); value = interval.substr(pos + 1, interval.size() - pos -1 ); m.insert(make_pair(key, value)); } pos = stuId.find(&quot;:&quot;); if (pos != -1) { key = stuId.substr(0, pos); value = stuId.substr(pos + 1, stuId.size() - pos -1 ); m.insert(make_pair(key, value)); } pos = stuName.find(&quot;:&quot;); if (pos != -1) { key = stuName.substr(0, pos); value = stuName.substr(pos + 1, stuName.size() - pos -1); m.insert(make_pair(key, value)); } pos = roomId.find(&quot;:&quot;); if (pos != -1) { key = roomId.substr(0, pos); value = roomId.substr(pos + 1, roomId.size() - pos -1 ); m.insert(make_pair(key, value)); } pos = status.find(&quot;:&quot;); if (pos != -1) { key = status.substr(0, pos); value = status.substr(pos + 1, status.size() - pos -1); m.insert(make_pair(key, value)); } this-&gt;m_orderData.insert(make_pair(this-&gt;m_Size, m)); this-&gt;m_Size++; } //测试代码 //for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++) //{ // cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl; // for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++) // { // cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;; // } // cout &lt;&lt; endl; //} ifs.close(); } 更新预约记录的成员函数updateOrder代码如下： void OrderFile::updateOrder() { if (this-&gt;m_Size == 0) { return; } ofstream ofs(ORDER_FILE, ios::out | ios::trunc); for (int i = 0; i &lt; m_Size;i++) { ofs &lt;&lt; &quot;date:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;date&quot;] &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;interval:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;interval&quot;] &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;stuId:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;stuId&quot;] &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;stuName:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;stuName&quot;] &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;roomId:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;roomId&quot;] &lt;&lt; &quot; &quot;; ofs &lt;&lt; &quot;status:&quot; &lt;&lt; this-&gt;m_orderData[i][&quot;status&quot;] &lt;&lt; endl; } ofs.close(); } 8.3.2 显示自身预约首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件 order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录 在Student类的void Student::showMyOrder()成员函数中，添加如下代码 //查看我的预约 void Student::showMyOrder() { OrderFile of; if (of.m_Size == 0) { cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } for (int i = 0; i &lt; of.m_Size; i++) { if (atoi(of.m_orderData[i][&quot;stuId&quot;].c_str()) == this-&gt;m_Id) { cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;]; cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;); cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;]; string status = &quot; 状态： &quot;; // 0 取消的预约 1 审核中 2 已预约 -1 预约失败 if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { status += &quot;审核中&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;) { status += &quot;预约成功&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;) { status += &quot;审核未通过，预约失败&quot;; } else { status += &quot;预约已取消&quot;; } cout &lt;&lt; status &lt;&lt; endl; } } system(&quot;pause&quot;); system(&quot;cls&quot;); } 测试效果如图： 8.3.3 显示所有预约在Student类的void Student::showAllOrder()成员函数中，添加如下代码 //查看所有预约 void Student::showAllOrder() { OrderFile of; if (of.m_Size == 0) { cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } for (int i = 0; i &lt; of.m_Size; i++) { cout &lt;&lt; i + 1 &lt;&lt; &quot;、 &quot;; cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;]; cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;); cout &lt;&lt; &quot; 学号：&quot; &lt;&lt; of.m_orderData[i][&quot;stuId&quot;]; cout &lt;&lt; &quot; 姓名：&quot; &lt;&lt; of.m_orderData[i][&quot;stuName&quot;]; cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;]; string status = &quot; 状态： &quot;; // 0 取消的预约 1 审核中 2 已预约 -1 预约失败 if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { status += &quot;审核中&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;) { status += &quot;预约成功&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;) { status += &quot;审核未通过，预约失败&quot;; } else { status += &quot;预约已取消&quot;; } cout &lt;&lt; status &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 测试效果如图： 8.4 取消预约在Student类的void Student::cancelOrder()成员函数中，添加如下代码 //取消预约 void Student::cancelOrder() { OrderFile of; if (of.m_Size == 0) { cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } cout &lt;&lt; &quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot; &lt;&lt; endl; vector&lt;int&gt;v; int index = 1; for (int i = 0; i &lt; of.m_Size; i++) { if (atoi(of.m_orderData[i][&quot;stuId&quot;].c_str()) == this-&gt;m_Id) { if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot; || of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;) { v.push_back(i); cout &lt;&lt; index ++ &lt;&lt; &quot;、 &quot;; cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;]; cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;); cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;]; string status = &quot; 状态： &quot;; // 0 取消的预约 1 审核中 2 已预约 -1 预约失败 if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { status += &quot;审核中&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;) { status += &quot;预约成功&quot;; } cout &lt;&lt; status &lt;&lt; endl; } } } cout &lt;&lt; &quot;请输入取消的记录,0代表返回&quot; &lt;&lt; endl; int select = 0; while (true) { cin &gt;&gt; select; if (select &gt;= 0 &amp;&amp; select &lt;= v.size()) { if (select == 0) { break; } else { // cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl; of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;0&quot;; of.updateOrder(); cout &lt;&lt; &quot;已取消预约&quot; &lt;&lt; endl; break; } } cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 测试取消预约： 再次查看个人预约记录： 查看所有预约 查看order.txt预约文件 至此，学生模块功能全部实现 9、 教师模块9.1 教师登录和注销9.1.1 构造函数 在Teacher类的构造函数中，初始化教师信息，代码如下： //有参构造 (职工编号，姓名，密码) Teacher::Teacher(int empId, string name, string pwd) { //初始化属性 this-&gt;m_EmpId = empId; this-&gt;m_Name = name; this-&gt;m_Pwd = pwd; } 9.1.2 教师子菜单 在机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口 将不同的分支提供出来 查看所有预约 审核预约 注销登录 实现注销功能 添加全局函数 void TeacherMenu(Person * &amp;manager) 代码如下： //教师菜单 void TeacherMenu(Identity * &amp;teacher) { while (true) { //教师菜单 teacher-&gt;operMenu(); Teacher* tea = (Teacher*)teacher; int select = 0; cin &gt;&gt; select; if (select == 1) { //查看所有预约 tea-&gt;showAllOrder(); } else if (select == 2) { //审核预约 tea-&gt;validOrder(); } else { delete teacher; cout &lt;&lt; &quot;注销成功&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } } } 9.1.3 菜单功能实现 在实现成员函数void Teacher::operMenu() 代码如下： //教师菜单界面 void Teacher::operMenu() { cout &lt;&lt; &quot;欢迎教师：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;登录！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\t\\t ----------------------------------\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 1.查看所有预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 2.审核预约 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| 0.注销登录 |\\n&quot;; cout &lt;&lt; &quot;\\t\\t| |\\n&quot;; cout &lt;&lt; &quot;\\t\\t ----------------------------------\\n&quot;; cout &lt;&lt; &quot;请选择您的操作： &quot; &lt;&lt; endl; } 9.1.4 接口对接 教师成功登录后，调用教师的子菜单界面 在教师登录分支中，添加代码： //进入教师子菜单 TeacherMenu(person); 添加效果如图： 测试对接，效果如图： 登录验证通过： 教师子菜单： 注销登录： 9.2 查看所有预约9.2.1 所有预约功能实现该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录 在Teacher.cpp中实现成员函数 void Teacher::showAllOrder() void Teacher::showAllOrder() { OrderFile of; if (of.m_Size == 0) { cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } for (int i = 0; i &lt; of.m_Size; i++) { cout &lt;&lt; i + 1 &lt;&lt; &quot;、 &quot;; cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;]; cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;); cout &lt;&lt; &quot; 学号：&quot; &lt;&lt; of.m_orderData[i][&quot;stuId&quot;]; cout &lt;&lt; &quot; 姓名：&quot; &lt;&lt; of.m_orderData[i][&quot;stuName&quot;]; cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;]; string status = &quot; 状态： &quot;; // 0 取消的预约 1 审核中 2 已预约 -1 预约失败 if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { status += &quot;审核中&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;2&quot;) { status += &quot;预约成功&quot;; } else if (of.m_orderData[i][&quot;status&quot;] == &quot;-1&quot;) { status += &quot;审核未通过，预约失败&quot;; } else { status += &quot;预约已取消&quot;; } cout &lt;&lt; status &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 9.2.2 测试功能运行测试教师身份的查看所有预约功能 测试效果如图： 9.3 审核预约9.3.1 审核功能实现功能描述：教师审核学生的预约，依据实际情况审核预约 在Teacher.cpp中实现成员函数 void Teacher::validOrder() 代码如下： //审核预约 void Teacher::validOrder() { OrderFile of; if (of.m_Size == 0) { cout &lt;&lt; &quot;无预约记录&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); return; } cout &lt;&lt; &quot;待审核的预约记录如下：&quot; &lt;&lt; endl; vector&lt;int&gt;v; int index = 0; for (int i = 0; i &lt; of.m_Size; i++) { if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { v.push_back(i); cout &lt;&lt; ++index &lt;&lt; &quot;、 &quot;; cout &lt;&lt; &quot;预约日期： 周&quot; &lt;&lt; of.m_orderData[i][&quot;date&quot;]; cout &lt;&lt; &quot; 时段：&quot; &lt;&lt; (of.m_orderData[i][&quot;interval&quot;] == &quot;1&quot; ? &quot;上午&quot; : &quot;下午&quot;); cout &lt;&lt; &quot; 机房：&quot; &lt;&lt; of.m_orderData[i][&quot;roomId&quot;]; string status = &quot; 状态： &quot;; // 0取消的预约 1 审核中 2 已预约 -1 预约失败 if (of.m_orderData[i][&quot;status&quot;] == &quot;1&quot;) { status += &quot;审核中&quot;; } cout &lt;&lt; status &lt;&lt; endl; } } cout &lt;&lt; &quot;请输入审核的预约记录,0代表返回&quot; &lt;&lt; endl; int select = 0; int ret = 0; while (true) { cin &gt;&gt; select; if (select &gt;= 0 &amp;&amp; select &lt;= v.size()) { if (select == 0) { break; } else { cout &lt;&lt; &quot;请输入审核结果&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、通过&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、不通过&quot; &lt;&lt; endl; cin &gt;&gt; ret; if (ret == 1) { of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;2&quot;; } else { of.m_orderData[v[select - 1]][&quot;status&quot;] = &quot;-1&quot;; } of.updateOrder(); cout &lt;&lt; &quot;审核完毕！&quot; &lt;&lt; endl; break; } } cout &lt;&lt; &quot;输入有误，请重新输入&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 9.3.2 测试审核预约测试 - 审核通过 审核通过情况 测试-审核未通过 审核未通过情况： 学生身份下查看记录： 审核预约成功！ 至此本案例制作完毕！ ^_^","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第四阶段","slug":"C-教程/C-第四阶段","permalink":"/categories/C-教程/C-第四阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第四阶段","slug":"C-教程/C-第四阶段","permalink":"/categories/C-教程/C-第四阶段/"}]},{"title":"演讲比赛管理","slug":"演讲比赛管理","date":"2021-02-03T07:12:50.000Z","updated":"2021-02-03T07:21:05.733Z","comments":true,"path":"2021/02/03/演讲比赛管理/","link":"","permalink":"/2021/02/03/演讲比赛管理/","excerpt":"","text":"演讲比赛流程管理系统1、 演讲比赛程序需求 1.1 比赛规则 学校举行一场演讲比赛，共有12个人参加。比赛共两轮，第一轮为淘汰赛，第二轮为决赛。 比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛 每名选手都有对应的编号，如 10001 ~ 10012 第一轮分为两个小组，每组6个人。 整体按照选手编号进行抽签后顺序演讲。 当小组演讲完后，淘汰组内排名最后的三个选手，前三名晋级，进入下一轮的比赛。 第二轮为决赛，前三名胜出 每轮比赛过后需要显示晋级选手的信息 1.2 程序功能 开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段 查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存 清空比赛记录：将文件中数据清空 退出比赛程序：可以退出当前程序 1.3 程序效果图： 2、 项目创建创建项目步骤如下： 创建新项目 添加文件 2.1 创建项目 打开vs2017后，点击创建新项目，创建新的C++项目 如图： 填写项目名称以及选取项目路径，点击确定生成项目 2.2 添加文件 右键源文件，进行添加文件操作 填写文件名称，点击添加 生成文件成功，效果如下图 至此，项目已创建完毕 3、 创建管理类功能描述： 提供菜单界面与用户交互 对演讲比赛流程进行控制 与文件的读写交互 3.1创建文件 在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件 3.2 头文件实现在speechManager.h中设计管理类 代码如下： #pragma once #include&lt;iostream&gt; using namespace std; //演讲管理类 class SpeechManager { public: //构造函数 SpeechManager(); //析构函数 ~SpeechManager(); }; 3.3 源文件实现在speechManager.cpp中将构造和析构函数空实现补全 #include &quot;speechManager.h&quot; SpeechManager::SpeechManager() { } SpeechManager::~SpeechManager() { } 至此演讲管理类以创建完毕 4、 菜单功能功能描述：与用户的沟通界面 4.1 添加成员函数在管理类speechManager.h中添加成员函数 void show_Menu(); 4.2 菜单功能实现 在管理类speechManager.cpp中实现 show_Menu()函数 void SpeechManager::show_Menu() { cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 欢迎参加演讲比赛 ************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 1.开始演讲比赛 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 2.查看往届记录 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 3.清空比赛记录 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 0.退出比赛程序 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl; cout &lt;&lt; endl; } 4.3 测试菜单功能 在演讲比赛流程管理系统.cpp中测试菜单功能 代码： #include&lt;iostream&gt; using namespace std; #include &quot;speechManager.h&quot; int main() { SpeechManager sm; sm.show_Menu(); system(&quot;pause&quot;); return 0; } 运行效果如图： 菜单界面搭建完毕 5、 退出功能5.1 提供功能接口 在main函数中提供分支选择，提供每个功能接口 代码： int main() { SpeechManager sm; int choice = 0; //用来存储用户的选项 while (true) { sm.show_Menu(); cout &lt;&lt; &quot;请输入您的选择： &quot; &lt;&lt; endl; cin &gt;&gt; choice; // 接受用户的选项 switch (choice) { case 1: //开始比赛 break; case 2: //查看记录 break; case 3: //清空记录 break; case 0: //退出系统 break; default: system(&quot;cls&quot;); //清屏 break; } } system(&quot;pause&quot;); return 0; } 5.2 实现退出功能在speechManager.h中提供退出系统的成员函数 void exitSystem(); 在speechManager.cpp中提供具体的功能实现 void SpeechManager::exitSystem() { cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl; system(&quot;pause&quot;); exit(0); } 5.3测试功能在main函数分支 0 选项中，调用退出程序的接口 运行测试效果如图： 6、演讲比赛功能6.1 功能分析比赛流程分析： 抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → 抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数 6.2 创建选手类 选手类中的属性包含：选手姓名、分数 头文件中创建 speaker.h文件，并添加代码： #pragma once #include&lt;iostream&gt; using namespace std; class Speaker { public: string m_Name; //姓名 double m_Score[2]; //分数 最多有两轮得分 }; 6.3 比赛6.3.1 成员属性添加 在speechManager.h中添加属性 //比赛选手 容器 12人 vector&lt;int&gt;v1; //第一轮晋级容器 6人 vector&lt;int&gt;v2; //胜利前三名容器 3人 vector&lt;int&gt;vVictory; //存放编号 以及对应的 具体选手 容器 map&lt;int, Speaker&gt; m_Speaker; 6.3.2 初始化属性 在speechManager.h中提供开始比赛的的成员函数 void initSpeech(); //初始化属性 void initSpeech(); 在speechManager.cpp中实现void initSpeech(); void SpeechManager::initSpeech() { //容器保证为空 this-&gt;v1.clear(); this-&gt;v2.clear(); this-&gt;vVictory.clear(); this-&gt;m_Speaker.clear(); //初始化比赛轮数 this-&gt;m_Index = 1; } SpeechManager构造函数中调用void initSpeech(); SpeechManager::SpeechManager() { //初始化属性 this-&gt;initSpeech(); } 6.3.3 创建选手 在speechManager.h中提供开始比赛的的成员函数 void createSpeaker(); //初始化创建12名选手 void createSpeaker(); 在speechManager.cpp中实现void createSpeaker(); void SpeechManager::createSpeaker() { string nameSeed = &quot;ABCDEFGHIJKL&quot;; for (int i = 0; i &lt; nameSeed.size(); i++) { string name = &quot;选手&quot;; name += nameSeed[i]; Speaker sp; sp.m_Name = name; for (int i = 0; i &lt; 2; i++) { sp.m_Score[i] = 0; } //12名选手编号 this-&gt;v1.push_back(i + 10001); //选手编号 以及对应的选手 存放到map容器中 this-&gt;m_Speaker.insert(make_pair(i + 10001, sp)); } } SpeechManager类的 构造函数中调用void createSpeaker(); SpeechManager::SpeechManager() { //初始化属性 this-&gt;initSpeech(); //创建选手 this-&gt;createSpeaker(); } 测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态 for (map&lt;int, Speaker&gt;::iterator it = sm.m_Speaker.begin(); it != sm.m_Speaker.end(); it++) { cout &lt;&lt; &quot;选手编号：&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; 姓名： &quot; &lt;&lt; it-&gt;second.m_Name &lt;&lt; &quot; 成绩： &quot; &lt;&lt; it-&gt;second.m_Score[0] &lt;&lt; endl; } 测试效果如图： 测试完毕后，可以将测试代码删除或注释。 6.3.4 开始比赛成员函数添加 在speechManager.h中提供开始比赛的的成员函数 void startSpeech(); 该函数功能是主要控制比赛的流程 //开始比赛 - 比赛流程控制 void startSpeech(); 在speechManager.cpp中将startSpeech的空实现先写入 我们可以先将整个比赛的流程 写到函数中 //开始比赛 void SpeechManager::startSpeech() { //第一轮比赛 //1、抽签 //2、比赛 //3、显示晋级结果 //第二轮比赛 //1、抽签 //2、比赛 //3、显示最终结果 //4、保存分数 } 6.3.5 抽签功能描述： 正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器 打乱次序即可 在speechManager.h中提供抽签的的成员函数 void speechDraw(); //抽签 void speechDraw(); 在speechManager.cpp中实现成员函数 void speechDraw(); void SpeechManager::speechDraw() { cout &lt;&lt; &quot;第 &lt;&lt; &quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot; &gt;&gt; 轮比赛选手正在抽签&quot;&lt;&lt;endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;抽签后演讲顺序如下：&quot; &lt;&lt; endl; if (this-&gt;m_Index == 1) { random_shuffle(v1.begin(), v1.end()); for (vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } else { random_shuffle(v2.begin(), v2.end()); for (vector&lt;int&gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; system(&quot;pause&quot;); cout &lt;&lt; endl; } 在startSpeech比赛流程控制的函数中，调用抽签函数 在main函数中，分支1选项中，调用开始比赛的接口 测试 6.3.6 开始比赛 在speechManager.h中提供比赛的的成员函数 void speechContest(); //比赛 void speechContest(); 在speechManager.cpp中实现成员函数 void speechContest(); void SpeechManager::speechContest() { cout &lt;&lt; &quot;------------- 第&quot;&lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮正式比赛开始：------------- &quot; &lt;&lt; endl; multimap&lt;double, int, greater&lt;int&gt;&gt; groupScore; //临时容器，保存key分数 value 选手编号 int num = 0; //记录人员数，6个为1组 vector &lt;int&gt;v_Src; //比赛的人员容器 if (this-&gt;m_Index == 1) { v_Src = v1; } else { v_Src = v2; } //遍历所有参赛选手 for (vector&lt;int&gt;::iterator it = v_Src.begin(); it != v_Src.end(); it++) { num++; //评委打分 deque&lt;double&gt;d; for (int i = 0; i &lt; 10; i++) { double score = (rand() % 401 + 600) / 10.f; // 600 ~ 1000 //cout &lt;&lt; score &lt;&lt; &quot; &quot;; d.push_back(score); } sort(d.begin(), d.end(), greater&lt;double&gt;()); //排序 d.pop_front(); //去掉最高分 d.pop_back(); //去掉最低分 double sum = accumulate(d.begin(), d.end(), 0.0f); //获取总分 double avg = sum / (double)d.size(); //获取平均分 //每个人平均分 //cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl; //打印分数 this-&gt;m_Speaker[*it].m_Score[this-&gt;m_Index - 1] = avg; //6个人一组，用临时容器保存 groupScore.insert(make_pair(avg, *it)); if (num % 6 == 0) { cout &lt;&lt; &quot;第&quot; &lt;&lt; num / 6 &lt;&lt; &quot;小组比赛名次：&quot; &lt;&lt; endl; for (multimap&lt;double, int, greater&lt;int&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end(); it++) { cout &lt;&lt; &quot;编号: &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot; 姓名： &quot; &lt;&lt; this-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; &quot; 成绩： &quot; &lt;&lt; this-&gt;m_Speaker[it-&gt;second].m_Score[this-&gt;m_Index - 1] &lt;&lt; endl; } int count = 0; //取前三名 for (multimap&lt;double, int, greater&lt;int&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end() &amp;&amp; count &lt; 3; it++, count++) { if (this-&gt;m_Index == 1) { v2.push_back((*it).second); } else { vVictory.push_back((*it).second); } } groupScore.clear(); cout &lt;&lt; endl; } } cout &lt;&lt; &quot;------------- 第&quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮比赛完毕 ------------- &quot; &lt;&lt; endl; system(&quot;pause&quot;); } 在startSpeech比赛流程控制的函数中，调用比赛函数 再次运行代码，测试比赛 6.3.7 显示比赛分数 在speechManager.h中提供比赛的的成员函数 void showScore(); //显示比赛结果 void showScore(); 在speechManager.cpp中实现成员函数 void showScore(); void SpeechManager::showScore() { cout &lt;&lt; &quot;---------第&quot; &lt;&lt; this-&gt;m_Index &lt;&lt; &quot;轮晋级选手信息如下：-----------&quot; &lt;&lt; endl; vector&lt;int&gt;v; if (this-&gt;m_Index == 1) { v = v2; } else { v = vVictory; } for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; &quot;选手编号：&quot; &lt;&lt; *it &lt;&lt; &quot; 姓名： &quot; &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; &quot; 得分： &quot; &lt;&lt; m_Speaker[*it].m_Score[this-&gt;m_Index - 1] &lt;&lt; endl; } cout &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); this-&gt;show_Menu(); } 在startSpeech比赛流程控制的函数中，调用显示比赛分数函数 运行代码，测试效果 6.3.8 第二轮比赛第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变 在startSpeech比赛流程控制的函数中，加入第二轮的流程 测试，将整个比赛流程都跑通 6.4 保存分数功能描述： 将每次演讲比赛的得分记录到文件中 功能实现： 在speechManager.h中添加保存记录的成员函数 void saveRecord(); //保存记录 void saveRecord(); 在speechManager.cpp中实现成员函数 void saveRecord(); void SpeechManager::saveRecord() { ofstream ofs; ofs.open(&quot;speech.csv&quot;, ios::out | ios::app); // 用输出的方式打开文件 -- 写文件 //将每个人数据写入到文件中 for (vector&lt;int&gt;::iterator it = vVictory.begin(); it != vVictory.end(); it++) { ofs &lt;&lt; *it &lt;&lt; &quot;,&quot; &lt;&lt; m_Speaker[*it].m_Score[1] &lt;&lt; &quot;,&quot;; } ofs &lt;&lt; endl; //关闭文件 ofs.close(); cout &lt;&lt; &quot;记录已经保存&quot; &lt;&lt; endl; } 在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数 测试，整个比赛完毕后记录保存情况 利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分 至此，整个演讲比赛功能制作完毕！ 7、 查看记录7.1 读取记录分数 在speechManager.h中添加保存记录的成员函数 void loadRecord(); 添加判断文件是否为空的标志 bool fileIsEmpty; 添加往届记录的容器map&lt;int, vector&lt;string&gt;&gt; m_Record; 其中m_Record 中的key代表第几届，value记录具体的信息 //读取记录 void loadRecord(); //文件为空的标志 bool fileIsEmpty; //往届记录 map&lt;int, vector&lt;string&gt;&gt; m_Record; 在speechManager.cpp中实现成员函数 void loadRecord(); void SpeechManager::loadRecord() { ifstream ifs(&quot;speech.csv&quot;, ios::in); //输入流对象 读取文件 if (!ifs.is_open()) { this-&gt;fileIsEmpty = true; cout &lt;&lt; &quot;文件不存在！&quot; &lt;&lt; endl; ifs.close(); return; } char ch; ifs &gt;&gt; ch; if (ifs.eof()) { cout &lt;&lt; &quot;文件为空!&quot; &lt;&lt; endl; this-&gt;fileIsEmpty = true; ifs.close(); return; } //文件不为空 this-&gt;fileIsEmpty = false; ifs.putback(ch); //读取的单个字符放回去 string data; int index = 0; while (ifs &gt;&gt; data) { //cout &lt;&lt; data &lt;&lt; endl; vector&lt;string&gt;v; int pos = -1; int start = 0; while (true) { pos = data.find(&quot;,&quot;, start); //从0开始查找 &#39;,&#39; if (pos == -1) { break; //找不到break返回 } string tmp = data.substr(start, pos - start); //找到了,进行分割 参数1 起始位置，参数2 截取长度 v.push_back(tmp); start = pos + 1; } this-&gt;m_Record.insert(make_pair(index, v)); index++; } ifs.close(); } 在SpeechManager构造函数中调用获取往届记录函数 7.2 查看记录功能 在speechManager.h中添加保存记录的成员函数 void showRecord(); //显示往届得分 void showRecord(); 在speechManager.cpp中实现成员函数 void showRecord(); void SpeechManager::showRecord() { for (int i = 0; i &lt; this-&gt;m_Record.size(); i++) { cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;届 &quot; &lt;&lt; &quot;冠军编号：&quot; &lt;&lt; this-&gt;m_Record[i][0] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][1] &lt;&lt; &quot; &quot; &quot;亚军编号：&quot; &lt;&lt; this-&gt;m_Record[i][2] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][3] &lt;&lt; &quot; &quot; &quot;季军编号：&quot; &lt;&lt; this-&gt;m_Record[i][4] &lt;&lt; &quot; 得分：&quot; &lt;&lt; this-&gt;m_Record[i][5] &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 7.3 测试功能在main函数分支 2 选项中，调用查看记录的接口 显示效果如图：（本次测试添加了4条记录） 7.4 bug解决目前程序中有几处bug未解决： 查看往届记录，若文件不存在或为空，并未提示 解决方式：在showRecord函数中，开始判断文件状态并加以判断 若记录为空或不存在，比完赛后依然提示记录为空 解决方式：saveRecord中更新文件为空的标志 比完赛后查不到本届比赛的记录，没有实时更新 解决方式：比赛完毕后，所有数据重置 在初始化时，没有初始化记录容器 解决方式：initSpeech中添加 初始化记录容器 每次记录都是一样的 解决方式：在main函数一开始 添加随机数种子 srand((unsigned int)time(NULL)); 所有bug解决后 测试： 8、 清空记录8.1 清空记录功能实现 在speechManager.h中添加保存记录的成员函数 void clearRecord(); //清空记录 void clearRecord(); 在speechManager.cpp中实现成员函数 void clearRecord(); void SpeechManager::clearRecord() { cout &lt;&lt; &quot;确认清空？&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、确认&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、返回&quot; &lt;&lt; endl; int select = 0; cin &gt;&gt; select; if (select == 1) { //打开模式 ios::trunc 如果存在删除文件并重新创建 ofstream ofs(&quot;speech.csv&quot;, ios::trunc); ofs.close(); //初始化属性 this-&gt;initSpeech(); //创建选手 this-&gt;createSpeaker(); //获取往届记录 this-&gt;loadRecord(); cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 8.2 测试清空在main函数分支 3 选项中，调用清空比赛记录的接口 运行程序，测试清空记录： speech.csv中记录也为空 至此本案例结束！ ^_^","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第三阶段","slug":"C-教程/C-第三阶段","permalink":"/categories/C-教程/C-第三阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第三阶段","slug":"C-教程/C-第三阶段","permalink":"/categories/C-教程/C-第三阶段/"}]},{"title":"C++第三阶段讲义","slug":"C-第三阶段讲义","date":"2021-02-03T07:12:36.000Z","updated":"2021-02-03T07:21:05.741Z","comments":true,"path":"2021/02/03/C-第三阶段讲义/","link":"","permalink":"/2021/02/03/C-第三阶段讲义/","excerpt":"","text":"C++提高编程 本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用 1 模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性 例如生活中的模板 一寸照片模板： PPT模板： 模板的特点： 模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板 C++提供两种模板机制:函数模板和类模板 1.2.1 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： template&lt;typename T&gt; 函数声明或定义 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： //交换整型函数 void swapInt(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp; } //交换浮点型函数 void swapDouble(double&amp; a, double&amp; b) { double temp = a; a = b; b = temp; } //利用模板提供通用的交换函数 template&lt;typename T&gt; void mySwap(T&amp; a, T&amp; b) { T temp = a; a = b; b = temp; } void test01() { int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T,才可以使用 模板必须要确定出T的数据类型，才可以使用 示例： //利用模板提供通用的交换函数 template&lt;class T&gt; void mySwap(T&amp; a, T&amp; b) { T temp = a; a = b; b = temp; } // 1、自动类型推导，必须推导出一致的数据类型T,才可以使用 void test01() { int a = 10; int b = 20; char c = &#39;c&#39;; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型 } // 2、模板必须要确定出T的数据类型，才可以使用 template&lt;class T&gt; void func() { cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl; } void test02() { //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板 } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例案例描述： 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例： //交换的函数模板 template&lt;typename T&gt; void mySwap(T &amp;a, T&amp;b) { T temp = a; a = b; b = temp; } template&lt;class T&gt; // 也可以替换成typename //利用选择排序，进行对数组从大到小的排序 void mySort(T arr[], int len) { for (int i = 0; i &lt; len; i++) { int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) { if (arr[max] &lt; arr[j]) { max = j; } } if (max != i) //如果最大数的下标不是i，交换两者 { mySwap(arr[max], arr[i]); } } } template&lt;typename T&gt; void printArray(T arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { //测试char数组 char charArr[] = &quot;bdcfeagh&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num); } void test02() { //测试int数组 int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 }; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num); } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：模板可以提高代码复用，需要熟练掌握 1.2.4 普通函数与函数模板的区别普通函数与函数模板区别： 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例： //普通函数 int myAdd01(int a, int b) { return a + b; } //函数模板 template&lt;class T&gt; T myAdd02(T a, T b) { return a + b; } //使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换 void test01() { int a = 10; int b = 20; char c = &#39;c&#39;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#39;c&#39;隐式转换为int类型 &#39;c&#39; 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换 } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T 1.2.5 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例： //普通函数与函数模板调用规则 void myPrint(int a, int b) { cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl; } template&lt;typename T&gt; void myPrint(T a, T b) { cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl; } template&lt;typename T&gt; void myPrint(T a, T b, T c) { cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; } void test01() { //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = &#39;a&#39;; char c2 = &#39;b&#39;; myPrint(c1, c2); //调用函数模板 } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性 1.2.6 模板的局限性局限性： 模板的通用性并不是万能的 例如： template&lt;class T&gt; void f(T a, T b) { a = b; } 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了 再例如： template&lt;class T&gt; void f(T a, T b) { if(a &gt; b) { ... } } 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板 示例： #include&lt;iostream&gt; using namespace std; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; //普通函数模板 template&lt;class T&gt; bool myCompare(T&amp; a, T&amp; b) { if (a == b) { return true; } else { return false; } } //具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型 //具体化优先于常规模板 template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2) { if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) { return true; } else { return false; } } void test01() { int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) { cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl; } } void test02() { Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) { cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl; } } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板1.3.1 类模板语法类模板作用： 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： template&lt;typename T&gt; 类 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType&gt; class Person { public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; } public: NameType mName; AgeType mAge; }; void test01() { // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999); P1.showPerson(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板 1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点： 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType = int&gt; class Person { public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; } public: NameType mName; AgeType mAge; }; //1、类模板没有自动类型推导的使用方式 void test01() { // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson(); } //2、类模板在模板参数列表中可以有默认参数 void test02() { Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson(); } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例： class Person1 { public: void showPerson1() { cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; } }; class Person2 { public: void showPerson2() { cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; } }; template&lt;class T&gt; class MyClass { public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() { obj.showPerson1(); } void fun2() { obj.showPerson2(); } }; void test01() { MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数 } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建 1.3.4 类模板对象做函数参数学习目标： 类模板实例化出的对象，向函数传参的方式 一共有三种传入方式： 指定传入的类型 — 直接显示对象的数据类型 参数模板化 — 将对象中的参数变为模板进行传递 整个类模板化 — 将这个对象类型 模板化进行传递 示例： #include &lt;string&gt; //类模板 template&lt;class NameType, class AgeType = int&gt; class Person { public: Person(NameType name, AgeType age) { this-&gt;mName = name; this-&gt;mAge = age; } void showPerson() { cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl; } public: NameType mName; AgeType mAge; }; //1、指定传入的类型 void printPerson1(Person&lt;string, int&gt; &amp;p) { p.showPerson(); } void test01() { Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100); printPerson1(p); } //2、参数模板化 template &lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt;&amp;p) { p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; } void test02() { Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90); printPerson2(p); } //3、整个类模板化 template&lt;class T&gt; void printPerson3(T &amp; p) { cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson(); } void test03() { Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30); printPerson3(p); } int main() { test01(); test02(); test03(); system(&quot;pause&quot;); return 0; } 总结： 通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例： template&lt;class T&gt; class Base { T m; }; //class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承 class Son :public Base&lt;int&gt; //必须指定一个类型 { }; void test01() { Son c; } //类模板继承类模板 ,可以用T2指定父类中的T类型 template&lt;class T1, class T2&gt; class Son2 :public Base&lt;T2&gt; { public: Son2() { cout &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; } }; void test02() { Son2&lt;int, char&gt; child1; } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：如果父类是类模板，子类需要指定出父类中T的数据类型 1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现 示例： #include &lt;string&gt; //类模板中成员函数类外实现 template&lt;class T1, class T2&gt; class Person { public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template&lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //成员函数 类外实现 template&lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } void test01() { Person&lt;string, int&gt; p(&quot;Tom&quot;, 20); p.showPerson(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：类模板中成员函数类外实现时，需要加上模板参数列表 1.3.7 类模板分文件编写学习目标： 掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例： person.hpp中代码： #pragma once #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; template&lt;class T1, class T2&gt; class Person { public: Person(T1 name, T2 age); void showPerson(); public: T1 m_Name; T2 m_Age; }; //构造函数 类外实现 template&lt;class T1, class T2&gt; Person&lt;T1, T2&gt;::Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //成员函数 类外实现 template&lt;class T1, class T2&gt; void Person&lt;T1, T2&gt;::showPerson() { cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; } 类模板分文件编写.cpp中代码 #include&lt;iostream&gt; using namespace std; //#include &quot;person.h&quot; #include &quot;person.cpp&quot; //解决方式1，包含cpp源文件 //解决方式2，将声明和实现写到一起，文件后缀名改为.hpp #include &quot;person.hpp&quot; void test01() { Person&lt;string, int&gt; p(&quot;Tom&quot;, 10); p.showPerson(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp 1.3.8 类模板与友元学习目标： 掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 示例： #include &lt;string&gt; //2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元 template&lt;class T1, class T2&gt; class Person; //如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到 //template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p) { cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; } template&lt;class T1, class T2&gt; class Person { //1、全局函数配合友元 类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl; } //全局函数配合友元 类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p); public: Person(T1 name, T2 age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } private: T1 m_Name; T2 m_Age; }; //1、全局函数在类内实现 void test01() { Person &lt;string, int &gt;p(&quot;Tom&quot;, 20); printPerson(p); } //2、全局函数在类外实现 void test02() { Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30); printPerson2(p); } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别 1.3.9 类模板案例案例描述: 实现一个通用的数组类，要求如下： 可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例： myArray.hpp中代码 #pragma once #include &lt;iostream&gt; using namespace std; template&lt;class T&gt; class MyArray { public: //构造函数 MyArray(int capacity) { this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; pAddress = new T[this-&gt;m_Capacity]; } //拷贝构造 MyArray(const MyArray &amp; arr) { this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) { //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-&gt;pAddress[i] = arr.pAddress[i]; } } //重载= 操作符 防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) { if (this-&gt;pAddress != NULL) { delete[] this-&gt;pAddress; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; } this-&gt;m_Capacity = myarray.m_Capacity; this-&gt;m_Size = myarray.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) { this-&gt;pAddress[i] = myarray[i]; } return *this; } //重载[] 操作符 arr[0] T&amp; operator [](int index) { return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 } //尾插法 void Push_back(const T &amp; val) { if (this-&gt;m_Capacity == this-&gt;m_Size) { return; } this-&gt;pAddress[this-&gt;m_Size] = val; this-&gt;m_Size++; } //尾删法 void Pop_back() { if (this-&gt;m_Size == 0) { return; } this-&gt;m_Size--; } //获取数组容量 int getCapacity() { return this-&gt;m_Capacity; } //获取数组大小 int getSize() { return this-&gt;m_Size; } //析构 ~MyArray() { if (this-&gt;pAddress != NULL) { delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; } } private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小 }; 类模板案例—数组类封装.cpp中 #include &quot;myArray.hpp&quot; #include &lt;string&gt; void printIntArray(MyArray&lt;int&gt;&amp; arr) { for (int i = 0; i &lt; arr.getSize(); i++) { cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //测试内置数据类型 void test01() { MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) { array1.Push_back(i); } cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl; } //测试自定义数据类型 class Person { public: Person() {} Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } public: string m_Name; int m_Age; }; void printPersonArray(MyArray&lt;Person&gt;&amp; personArr) { for (int i = 0; i &lt; personArr.getSize(); i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl; } } void test02() { //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(&quot;孙悟空&quot;, 30); Person p2(&quot;韩信&quot;, 20); Person p3(&quot;妲己&quot;, 18); Person p4(&quot;王昭君&quot;, 15); Person p5(&quot;赵云&quot;, 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl; } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 能够利用所学知识点实现通用的数组 2 STL初识2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL ​ 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器容器：置物之所也 STL容器就是将运用最广泛的一些数据结构实现出来 常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等 这些容器分为序列式容器和关联式容器两种: ​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系 算法：问题之解法也 有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms) 算法分为:质变算法和非质变算法。 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等 迭代器：容器和算法之间粘合剂 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 每个容器都有自己专属的迭代器 迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针 迭代器种类： 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、==、！= 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、–， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;= 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器 2.5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力 STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器 2.5.1 vector存放内置数据类型容器： vector 算法： for_each 迭代器： vector&lt;int&gt;::iterator 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; void MyPrint(int val) { cout &lt;&lt; val &lt;&lt; endl; } void test01() { //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector&lt;int&gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型 vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) { cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; } //第二种遍历方式： for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; endl; } cout &lt;&lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint); } int main() { test01(); system(&quot;pause&quot;); return 0; } 2.5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出 示例： #include &lt;vector&gt; #include &lt;string&gt; //自定义数据类型 class Person { public: Person(string name, int age) { mName = name; mAge = age; } public: string mName; int mAge; }; //存放对象 void test01() { vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl; } } //放对象指针 void test02() { vector&lt;Person*&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); Person p5(&quot;eee&quot;, 50); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) { Person * p = (*it); cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl; } } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 2.5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出 示例： #include &lt;vector&gt; //容器嵌套容器 void test01() { vector&lt; vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for (int i = 0; i &lt; 4; i++) { v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); } //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) { for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) { cout &lt;&lt; *vit &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 3 STL- 常用容器3.1 string容器3.1.1 string基本概念本质： string是C++风格的字符串，而string本质上是一个类 string和char * 区别： char * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点： string 类内部封装了很多成员方法 例如：查找find，拷贝copy，删除delete 替换replace，插入insert string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责 3.1.2 string构造函数构造函数原型： string(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化 string(const string&amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化 示例： #include &lt;string&gt; //string构造 void test01() { string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl; const char* str = &quot;hello world&quot;; string s2(str); //把c_string转换成了string cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl; string s4(10, &#39;a&#39;); cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：string的多种构造方式没有可比性，灵活使用即可 3.1.3 string赋值操作功能描述： 给string字符串进行赋值 赋值的函数原型： string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串 string&amp; operator=(char c); //字符赋值给当前的字符串 string&amp; assign(const char *s); //把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串 string&amp; assign(int n, char c); //用n个字符c赋给当前字符串 示例： //赋值 void test01() { string str1; str1 = &quot;hello world&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = &#39;a&#39;; cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(&quot;hello c++&quot;); cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(&quot;hello c++&quot;,5); cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, &#39;x&#39;); cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： ​ string的赋值方式很多，operator= 这种方式是比较实用的 3.1.4 string字符串拼接功能描述： 实现在字符串末尾拼接字符串 函数原型： string&amp; operator+=(const char* str); //重载+=操作符 string&amp; operator+=(const char c); //重载+=操作符 string&amp; operator+=(const string&amp; str); //重载+=操作符 string&amp; append(const char *s); //把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); //同operator+=(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 示例： //字符串拼接 void test01() { string str1 = &quot;我&quot;; str1 += &quot;爱玩游戏&quot;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; str1 += &#39;:&#39;; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str2 = &quot;LOL DNF&quot;; str1 += str2; cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; string str3 = &quot;I&quot;; str3.append(&quot; love &quot;); str3.append(&quot;game abcde&quot;, 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：字符串拼接的重载版本很多，初学阶段记住几种即可 3.1.5 string查找和替换功能描述： 查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型： int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s 示例： //查找和替换 void test01() { //查找 string str1 = &quot;abcdefgde&quot;; int pos = str1.find(&quot;de&quot;); if (pos == -1) { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; } pos = str1.rfind(&quot;de&quot;); cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl; } void test02() { //替换 string str1 = &quot;abcdefgde&quot;; str1.replace(1, 3, &quot;1111&quot;); cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl; } int main() { //test01(); //test02(); system(&quot;pause&quot;); return 0; } 总结： find查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较功能描述： 字符串之间的比较 比较方式： 字符串比较是按字符的ASCII码进行对比 = 返回 0 > 返回 1 &lt; 返回 -1 函数原型： int compare(const string &amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 示例： //字符串比较 void test01() { string s1 = &quot;hello&quot;; string s2 = &quot;aello&quot;; int ret = s1.compare(s2); if (ret == 0) { cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl; } else if (ret &gt; 0) { cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大 3.1.7 string字符存取string中单个字符存取方式有两种 char&amp; operator[](int n); //通过[]方式取字符 char&amp; at(int n); //通过at方法获取字符 示例： void test01() { string str = &quot;hello world&quot;; for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; for (int i = 0; i &lt; str.size(); i++) { cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //字符修改 str[0] = &#39;x&#39;; str.at(1) = &#39;x&#39;; cout &lt;&lt; str &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at 3.1.8 string插入和删除功能描述： 对string字符串进行插入和删除字符操作 函数原型： string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 示例： //字符串插入和删除 void test01() { string str = &quot;hello&quot;; str.insert(1, &quot;111&quot;); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：插入和删除的起始下标都是从0开始 3.1.9 string子串功能描述： 从字符串中获取想要的子串 函数原型： string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 示例： //子串 void test01() { string str = &quot;abcdefg&quot;; string subStr = str.substr(1, 3); cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl; string email = &quot;hello@sina.com&quot;; int pos = email.find(&quot;@&quot;); string username = email.substr(0, pos); cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息 3.2 vector容器3.2.1 vector基本概念功能： vector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数功能描述： 创建vector容器 函数原型： vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); //拷贝构造函数。 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：vector的多种构造方式没有可比性，灵活使用即可 3.2.3 vector赋值操作功能描述： 给vector容器进行赋值 函数原型： vector&amp; operator=(const vector &amp;vec);//重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //赋值操作 void test01() { vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： vector赋值方式比较简单，使用operator=，或者assign都可以 3.2.4 vector容量和大小功能描述： 对vector容器的容量和大小操作 函数原型： empty(); //判断容器是否为空 capacity(); //容器的容量 size(); //返回容器中元素的个数 resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); if (v1.empty()) { cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl; } //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 判断是否为空 — empty 返回元素个数 — size 返回容器容量 — capacity 重新指定大小 — resize 3.2.5 vector插入和删除功能描述： 对vector容器进行插入、删除操作 函数原型： push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //插入和删除 void test01() { vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 尾插 — push_back 尾删 — pop_back 插入 — insert (位置迭代器) 删除 — erase （位置迭代器） 清空 — clear 3.2.6 vector数据存取功能描述： 对vector中的数据的存取操作 函数原型： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例： #include &lt;vector&gt; void test01() { vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) { cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 除了用迭代器获取vector容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器功能描述： 实现两个容器内元素进行互换 函数原型： swap(vec); // 将vec与本身的元素互换 示例： #include &lt;vector&gt; void printVector(vector&lt;int&gt;&amp; v) { for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); } printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) { v2.push_back(i); } printVector(v2); //互换容器 cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2); } void test02() { vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); } cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl; } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果 3.2.8 vector预留空间功能描述： 减少vector在动态扩展容量时的扩展次数 函数原型： reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 ​ 示例： #include &lt;vector&gt; void test01() { vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i &lt; 100000; i++) { v.push_back(i); if (p != &amp;v[0]) { p = &amp;v[0]; num++; } } cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：如果数据量较大，可以一开始利用reserve预留空间 3.3 deque容器3.3.1 deque容器基本概念功能： 双端数组，可以对头端进行插入删除操作 deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间 deque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数功能描述： deque容器构造 函数原型： deque&lt;T&gt; deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); //拷贝构造函数 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //deque构造 void test01() { deque&lt;int&gt; d1; //无参构造函数 for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque&lt;int&gt; d2(d1.begin(),d1.end()); printDeque(d2); deque&lt;int&gt;d3(10,100); printDeque(d3); deque&lt;int&gt;d4 = d3; printDeque(d4); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可 3.3.3 deque赋值操作功能描述： 给deque容器进行赋值 函数原型： deque&amp; operator=(const deque &amp;deq); //重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //赋值操作 void test01() { deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：deque赋值操作也与vector相同，需熟练掌握 3.3.4 deque大小操作功能描述： 对deque容器的大小进行操作 函数原型： deque.empty(); //判断容器是否为空 deque.size(); //返回容器中元素的个数 deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 ​ 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //大小操作 void test01() { deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) { d1.push_back(i); } printDeque(d1); //判断容器是否为空 if (d1.empty()) { cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl; //统计大小 cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl; } //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： deque没有容量的概念 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.3.5 deque 插入和删除功能描述： 向deque容器中插入和删除数据 函数原型： 两端插入操作： push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作： insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 ​ ​ 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //两端操作 void test01() { deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d); } //插入 void test02() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d); } //删除 void test03() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d); } int main() { //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; } 总结： 插入和删除提供的位置是迭代器！ 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 3.3.6 deque 数据存取功能描述： 对deque 中的数据的存取操作 函数原型： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例： #include &lt;deque&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //数据存取 void test01() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) { cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) { cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 除了用迭代器获取deque容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序功能描述： 利用算法实现对deque容器进行排序 算法： sort(iterator beg, iterator end) //对beg和end区间内元素进行排序 示例： #include &lt;deque&gt; #include &lt;algorithm&gt; void printDeque(const deque&lt;int&gt;&amp; d) { for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：sort算法非常实用，使用时包含头文件 algorithm即可 3.4 案例-评委打分3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。 3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码： //选手类 class Person { public: Person(string name, int score) { this-&gt;m_Name = name; this-&gt;m_Score = score; } string m_Name; //姓名 int m_Score; //平均分 }; void createPerson(vector&lt;Person&gt;&amp;v) { string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; 5; i++) { string name = &quot;选手&quot;; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); } } //打分 void setScore(vector&lt;Person&gt;&amp;v) { for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { //将评委的分数 放入到deque容器中 deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) { int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); } //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl; //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) //{ // cout &lt;&lt; *dit &lt;&lt; &quot; &quot;; //} //cout &lt;&lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) { sum += *dit; //累加每个评委的分数 } int avg = sum / d.size(); //将平均分 赋值给选手身上 it-&gt;m_Score = avg; } } void showScore(vector&lt;Person&gt;&amp;v) { for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl; } } int main() { //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector&lt;Person&gt;v; //存放选手容器 createPerson(v); //测试 //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) //{ // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl; //} //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(&quot;pause&quot;); return 0; } 总结： 选取不同的容器操作数据，可以提升代码的效率 3.5 stack容器3.5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为 栈中进入数据称为 — 入栈 push 栈中弹出数据称为 — 出栈 pop 生活中的栈： 3.5.2 stack 常用接口功能描述：栈容器常用的对外接口 构造函数： stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack &amp;stk); //拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk); //重载等号操作符 数据存取： push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 示例： #include &lt;stack&gt; //栈容器常用接口 void test01() { //创建栈容器 栈容器必须符合先进后出 stack&lt;int&gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) { //输出栈顶元素 cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl; //弹出栈顶元素 s.pop(); } cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 入栈 — push 出栈 — pop 返回栈顶 — top 判断栈是否为空 — empty 返回栈大小 — size 3.6 queue 容器3.6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口 队列容器允许从一端新增元素，从另一端移除元素 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为 队列中进数据称为 — 入队 push 队列中出数据称为 — 出队 pop 生活中的队列： 3.6.2 queue 常用接口功能描述：栈容器常用的对外接口 构造函数： queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que); //拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que); //重载等号操作符 数据存取： push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 示例： #include &lt;queue&gt; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; void test01() { //创建队列 queue&lt;Person&gt; q; //准备数据 Person p1(&quot;唐僧&quot;, 30); Person p2(&quot;孙悟空&quot;, 1000); Person p3(&quot;猪八戒&quot;, 900); Person p4(&quot;沙僧&quot;, 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) { //输出队头元素 cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl; cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl; cout &lt;&lt; endl; //弹出队头元素 q.pop(); } cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 入队 — push 出队 — pop 返回队头元素 — front 返回队尾元素 — back 判断队是否为空 — empty 返回队列大小 — size 3.7 list容器3.7.1 list基本概念功能：将数据进行链式存储 链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的 链表的组成：链表由一系列结点组成 结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域 STL中的链表是一个双向循环链表 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 总结：STL中List和vector是两个最常被使用的容器，各有优缺点 3.7.2 list构造函数功能描述： 创建list容器 函数原型： list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list &amp;lst); //拷贝构造函数。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } void test01() { list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list&lt;int&gt;L2(L1.begin(),L1.end()); printList(L2); list&lt;int&gt;L3(L2); printList(L3); list&lt;int&gt;L4(10, 1000); printList(L4); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：list构造方式同其他几个STL常用容器，熟练掌握即可 3.7.3 list 赋值和交换功能描述： 给list容器进行赋值，以及交换list容器 函数原型： assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //赋值和交换 void test01() { list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4); } //交换 void test02() { list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; printList(L1); printList(L2); } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：list赋值和交换操作能够灵活运用即可 3.7.4 list 大小操作功能描述： 对list容器的大小进行操作 函数原型： size(); //返回容器中元素的个数 empty(); //判断容器是否为空 resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //大小操作 void test01() { list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) { cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl; } //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.7.5 list 插入和删除功能描述： 对list容器进行数据的插入和删除 函数原型： push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例： #include &lt;list&gt; void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //插入和删除 void test01() { list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 插入 — insert 删除 — erase 移除 — remove 清空 — clear 3.7.6 list 数据存取功能描述： 对list容器中数据进行存取 函数原型： front(); //返回第一个元素。 back(); //返回最后一个元素。 示例： #include &lt;list&gt; //数据存取 void test01() { list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1 } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： list容器中不可以通过[]或者at方式访问数据 返回第一个元素 — front 返回最后一个元素 — back 3.7.7 list 反转和排序功能描述： 将容器中的元素反转，以及将容器中的数据进行排序 函数原型： reverse(); //反转链表 sort(); //链表排序 示例： void printList(const list&lt;int&gt;&amp; L) { for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } bool myCompare(int val1 , int val2) { return val1 &gt; val2; } //反转和排序 void test01() { list&lt;int&gt; L; L.push_back(90); L.push_back(30); L.push_back(20); L.push_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 反转 — reverse 排序 — sort （成员函数） 3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高 排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序 示例： #include &lt;list&gt; #include &lt;string&gt; class Person { public: Person(string name, int age , int height) { m_Name = name; m_Age = age; m_Height = height; } public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高 }; bool ComparePerson(Person&amp; p1, Person&amp; p2) { if (p1.m_Age == p2.m_Age) { return p1.m_Height &gt; p2.m_Height; } else { return p1.m_Age &lt; p2.m_Age; } } void test01() { list&lt;Person&gt; L; Person p1(&quot;刘备&quot;, 35 , 175); Person p2(&quot;曹操&quot;, 45 , 180); Person p3(&quot;孙权&quot;, 40 , 170); Person p4(&quot;赵云&quot;, 25 , 190); Person p5(&quot;张飞&quot;, 35 , 160); Person p6(&quot;关羽&quot;, 35 , 200); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; } cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl; L.sort(ComparePerson); //排序 for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂 3.8 set/ multiset 容器3.8.1 set基本概念简介： 所有元素都会在插入时自动被排序 本质： set/multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别： set不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值功能描述：创建set容器以及赋值 构造： set&lt;T&gt; st; //默认构造函数： set(const set &amp;st); //拷贝构造函数 赋值： set&amp; operator=(const set &amp;st); //重载等号操作符 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) { for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //构造和赋值 void test01() { set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： set容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换功能描述： 统计set容器大小以及交换set容器 函数原型： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) { for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //大小 void test01() { set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) { cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl; } } //交换 void test02() { set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2); } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.8.4 set插入和删除功能描述： set容器进行插入数据和删除数据 函数原型： insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 示例： #include &lt;set&gt; void printSet(set&lt;int&gt; &amp; s) { for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //插入和删除 void test01() { set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 插入 — insert 删除 — erase 清空 — clear 3.8.5 set查找和统计功能描述： 对set容器进行查找数据以及统计数据 函数原型： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例： #include &lt;set&gt; //查找和统计 void test01() { set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) { cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; } //统计 int num = s1.count(30); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 查找 — find （返回的是迭代器） 统计 — count （对于set，结果为0或者1） 3.8.6 set和multiset区别学习目标： 掌握set和multiset的区别 区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例： #include &lt;set&gt; //set和multiset区别 void test01() { set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); if (ret.second) { cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl; } ret = s.insert(10); if (ret.second) { cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl; } //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建功能描述： 成对出现的数据，利用对组可以返回两个数据 两种创建方式： pair&lt;type, type&gt; p ( value1, value2 ); pair&lt;type, type&gt; p = make_pair( value1, value2 ); 示例： #include &lt;string&gt; //对组创建 void test01() { pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 两种方式都可以创建对组，记住一种即可 3.8.8 set容器排序学习目标： set容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点： 利用仿函数，可以改变排序规则 示例一 set存放内置数据类型 #include &lt;set&gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void test01() { set&lt;int&gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); //默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //指定排序规则 set&lt;int,MyCompare&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：利用仿函数可以指定set容器的排序规则 示例二 set存放自定义数据类型 #include &lt;set&gt; #include &lt;string&gt; class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; class comparePerson { public: bool operator()(const Person&amp; p1, const Person &amp;p2) { //按照年龄进行排序 降序 return p1.m_Age &gt; p2.m_Age; } }; void test01() { set&lt;Person, comparePerson&gt; s; Person p1(&quot;刘备&quot;, 23); Person p2(&quot;关羽&quot;, 27); Person p3(&quot;张飞&quot;, 25); Person p4(&quot;赵云&quot;, 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 对于自定义数据类型，set必须指定排序规则才可以插入数据 3.9 map/ multimap容器3.9.1 map基本概念简介： map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质： map/multimap属于关联式容器，底层结构是用二叉树实现。 优点： 可以根据key值快速找到value值 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值功能描述： 对map容器进行构造和赋值操作 函数原型： 构造： map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); //重载等号操作符 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) { for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { map&lt;int,int&gt;m; //默认构造 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); printMap(m); map&lt;int, int&gt;m2(m); //拷贝构造 printMap(m2); map&lt;int, int&gt;m3; m3 = m2; //赋值 printMap(m3); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：map中所有元素都是成对出现，插入数据时候要使用对组 3.9.3 map大小和交换功能描述： 统计map容器大小以及交换map容器 函数原型： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) { for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); if (m.empty()) { cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl; cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl; } } //交换 void test02() { map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;m2; m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl; printMap(m); printMap(m2); cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl; m.swap(m2); printMap(m); printMap(m2); } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.9.4 map插入和删除功能描述： map容器进行插入数据和删除数据 函数原型： insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。 示例： #include &lt;map&gt; void printMap(map&lt;int,int&gt;&amp;m) { for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } cout &lt;&lt; endl; } void test01() { //插入 map&lt;int, int&gt; m; //第一种插入方式 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： map插入方式很多，记住其一即可 插入 — insert 删除 — erase 清空 — clear 3.9.5 map查找和统计功能描述： 对map容器进行查找数据以及统计数据 函数原型： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例： #include &lt;map&gt; //查找和统计 void test01() { map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找 map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) { cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl; } //统计 int num = m.count(3); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 查找 — find （返回的是迭代器） 统计 — count （对于map，结果为0或者1） 3.9.6 map容器排序学习目标： map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点: 利用仿函数，可以改变排序规则 示例： #include &lt;map&gt; class MyCompare { public: bool operator()(int v1, int v2) { return v1 &gt; v2; } }; void test01() { //默认从小到大排序 //利用仿函数实现从大到小排序 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) { cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码： #include&lt;iostream&gt; using namespace std; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;ctime&gt; /* - 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 - 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 - 随机给10名员工分配部门和工资 - 通过multimap进行信息的插入 key(部门编号) value(员工) - 分部门显示员工信息 */ #define CEHUA 0 #define MEISHU 1 #define YANFA 2 class Worker { public: string m_Name; int m_Salary; }; void createWorker(vector&lt;Worker&gt;&amp;v) { string nameSeed = &quot;ABCDEFGHIJ&quot;; for (int i = 0; i &lt; 10; i++) { Worker worker; worker.m_Name = &quot;员工&quot;; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); } } //员工分组 void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m) { for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) { //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); } } void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m) { // 0 A B C 1 D E 2 F G ... cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl; multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; } } int main() { srand((unsigned int)time(NULL)); //1、创建员工 vector&lt;Worker&gt;vWorker; createWorker(vWorker); //2、员工分组 multimap&lt;int, Worker&gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //{ // cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; //} system(&quot;pause&quot;); return 0; } 总结： 当数据以键值对形式存在，可以考虑用map 或 multimap 4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念： 重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 4.1.2 函数对象使用特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例: #include &lt;string&gt; //1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 class MyAdd { public : int operator()(int v1,int v2) { return v1 + v2; } }; void test01() { MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl; } //2、函数对象可以有自己的状态 class MyPrint { public: MyPrint() { count = 0; } void operator()(string test) { cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 } int count; //内部自己的状态 }; void test02() { MyPrint myPrint; myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); myPrint(&quot;hello world&quot;); cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl; } //3、函数对象可以作为参数传递 void doPrint(MyPrint &amp;mp , string test) { mp(test); } void test03() { MyPrint myPrint; doPrint(myPrint, &quot;Hello C++&quot;); } int main() { //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; } 总结： 仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词4.2.1 谓词概念概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词示例： #include &lt;vector&gt; #include &lt;algorithm&gt; //1.一元谓词 struct GreaterFive{ bool operator()(int val) { return val &gt; 5; } }; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：参数只有一个的谓词，称为一元谓词 4.2.3 二元谓词示例： #include &lt;vector&gt; #include &lt;algorithm&gt; //二元谓词 class MyCompare { public: bool operator()(int num1, int num2) { return num1 &gt; num2; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：参数只有两个的谓词，称为二元谓词 4.3 内建函数对象4.3.1 内建函数对象意义概念： STL内建了一些函数对象 分类: 算术仿函数 关系仿函数 逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include&lt;functional&gt; 4.3.2 算术仿函数功能描述： 实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型： template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数 示例： #include &lt;functional&gt; //negate void test01() { negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl; } //plus void test02() { plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl; } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt; 4.3.3 关系仿函数功能描述： 实现关系对比 仿函数原型： template&lt;class T&gt; bool equal_to&lt;T&gt; //等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于 template&lt;class T&gt; bool greater&lt;T&gt; //大于 template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于 template&lt;class T&gt; bool less&lt;T&gt; //小于 template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于 示例： #include &lt;functional&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class MyCompare { public: bool operator()(int v1,int v2) { return v1 &gt; v2; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：关系仿函数中最常用的就是greater&lt;&gt;大于 4.3.4 逻辑仿函数功能描述： 实现逻辑运算 函数原型： template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非 示例： #include &lt;vector&gt; #include &lt;functional&gt; #include &lt;algorithm&gt; void test01() { vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) { cout &lt;&lt; *it &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：逻辑仿函数实际应用较少，了解即可 5 STL- 常用算法概述: 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类,用以声明函数对象。 5.1 常用遍历算法学习目标： 掌握常用的遍历算法 算法简介： for_each //遍历容器 transform //搬运容器到另一个容器中 5.1.1 for_each功能描述： 实现遍历容器 函数原型： for_each(iterator beg, iterator end, _func); // 遍历算法 遍历容器元素 // beg 开始迭代器 // end 结束迭代器 // _func 函数或者函数对象 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; //普通函数 void print01(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } //函数对象 class print02 { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; //for_each算法基本用法 void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握 5.1.2 transform功能描述： 搬运容器到另一个容器中 函数原型： transform(iterator beg1, iterator end1, iterator beg2, _func); //beg1 源容器开始迭代器 //end1 源容器结束迭代器 //beg2 目标容器开始迭代器 //_func 函数或者函数对象 示例： #include&lt;vector&gt; #include&lt;algorithm&gt; //常用遍历算法 搬运 transform class TransForm { public: int operator()(int val) { return val; } }; class MyPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint()); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运 5.2 常用查找算法学习目标： 掌握常用的查找算法 算法简介： find //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 5.2.1 find功能描述： 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型： find(iterator beg, iterator end, value); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i + 1); } //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) { cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl; } } class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } //重载== bool operator==(const Person&amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } return false; } public: string m_Name; int m_Age; }; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) { cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } 总结： 利用find可以在容器中找指定的元素，返回值是迭代器 5.2.2 find_if功能描述： 按条件查找元素 函数原型： find_if(iterator beg, iterator end, _Pred); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // _Pred 函数或者谓词（返回bool类型的仿函数） 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;string&gt; //内置数据类型 class GreaterFive { public: bool operator()(int val) { return val &gt; 5; } }; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) { v.push_back(i + 1); } vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) { cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl; } } //自定义数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } public: string m_Name; int m_Age; }; class Greater20 { public: bool operator()(Person &amp;p) { return p.m_Age &gt; 20; } }; void test02() { vector&lt;Person&gt; v; //创建数据 Person p1(&quot;aaa&quot;, 10); Person p2(&quot;bbb&quot;, 20); Person p3(&quot;ccc&quot;, 30); Person p4(&quot;ddd&quot;, 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) { cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl; } } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略 5.2.3 adjacent_find功能描述： 查找相邻重复元素 函数原型： adjacent_find(iterator beg, iterator end); // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器 // beg 开始迭代器 // end 结束迭代器 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void test01() { vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) { cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl; } } 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法 5.2.4 binary_search功能描述： 查找指定元素是否存在 函数原型： bool binary_search(iterator beg, iterator end, value); // 查找指定的元素，查到 返回true 否则false // 注意: 在无序序列中不可用 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void test01() { vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) { v.push_back(i); } //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) { cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列 5.2.5 count功能描述： 统计元素个数 函数原型： count(iterator beg, iterator end, value); // 统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // value 统计的元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; //内置数据类型 void test01() { vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } bool operator==(const Person &amp; p) { if (this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } string m_Name; int m_Age; }; void test02() { vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(&quot;诸葛亮&quot;,35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结： 统计自定义数据类型时候，需要配合重载 operator== 5.2.6 count_if功能描述： 按条件统计元素个数 函数原型： count_if(iterator beg, iterator end, _Pred); // 按条件统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // _Pred 谓词 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class Greater4 { public: bool operator()(int val) { return val &gt;= 4; } }; //内置数据类型 void test01() { vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl; } //自定义数据类型 class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; } string m_Name; int m_Age; }; class AgeLess35 { public: bool operator()(const Person &amp;p) { return p.m_Age &lt; 35; } }; void test02() { vector&lt;Person&gt; v; Person p1(&quot;刘备&quot;, 35); Person p2(&quot;关羽&quot;, 35); Person p3(&quot;张飞&quot;, 35); Person p4(&quot;赵云&quot;, 30); Person p5(&quot;曹操&quot;, 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl; } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：按值统计用count，按条件统计用count_if 5.3 常用排序算法学习目标： 掌握常用的排序算法 算法简介： sort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 5.3.1 sort功能描述： 对容器内元素进行排序 函数原型： sort(iterator beg, iterator end, _Pred); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // _Pred 谓词 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; void myPrint(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：sort属于开发中最常用的算法之一，需熟练掌握 5.3.2 random_shuffle功能描述： 洗牌 指定范围内的元素随机调整次序 函数原型： random_shuffle(iterator beg, iterator end); // 指定范围内的元素随机调整次序 // beg 开始迭代器 // end 结束迭代器 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;ctime&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) { v.push_back(i); } for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子 5.3.3 merge功能描述： 两个容器元素合并，并存储到另一容器中 函数原型： merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中 // 注意: 两个容器必须是有序的 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++) { v1.push_back(i); v2.push_back(i + 1); } vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：merge合并的两个容器必须的有序序列 5.3.4 reverse功能描述： 将容器内元素进行反转 函数原型： reverse(iterator beg, iterator end); // 反转指定范围的元素 // beg 开始迭代器 // end 结束迭代器 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：reverse反转区间内元素，面试题可能涉及到 5.4 常用拷贝和替换算法学习目标： 掌握常用的拷贝和替换算法 算法简介： copy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 5.4.1 copy功能描述： 容器内指定范围的元素拷贝到另一容器中 函数原型： copy(iterator beg, iterator end, iterator dest); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // dest 目标起始迭代器 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) { v1.push_back(i + 1); } vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：利用copy算法在拷贝时，目标容器记得提前开辟空间 5.4.2 replace功能描述： 将容器内指定范围的旧元素修改为新元素 函数原型： replace(iterator beg, iterator end, oldvalue, newvalue); // 将区间内旧元素 替换成 新元素 // beg 开始迭代器 // end 结束迭代器 // oldvalue 旧元素 // newvalue 新元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：replace会替换区间内满足条件的元素 5.4.3 replace_if功能描述: 将区间内满足条件的元素，替换成指定元素 函数原型： replace_if(iterator beg, iterator end, _pred, newvalue); // 按条件替换元素，满足条件的替换成指定元素 // beg 开始迭代器 // end 结束迭代器 // _pred 谓词 // newvalue 替换的新元素 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; class ReplaceGreater30 { public: bool operator()(int val) { return val &gt;= 30; } }; void test01() { vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件 5.4.4 swap功能描述： 互换两个容器的元素 函数原型： swap(container c1, container c2); // 互换两个容器的元素 // c1容器1 // c2容器2 ​ 示例： #include &lt;algorithm&gt; #include &lt;vector&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+100); } cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：swap交换容器时，注意交换的容器要同种类型 5.5 常用算术生成算法学习目标： 掌握常用的算术生成算法 注意： 算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt; 算法简介： accumulate // 计算容器元素累计总和 fill // 向容器中添加元素 ​ 5.5.1 accumulate功能描述： 计算区间内 容器元素累计总和 函数原型： accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和 // beg 开始迭代器 // end 结束迭代器 // value 起始值 示例： #include &lt;numeric&gt; #include &lt;vector&gt; void test01() { vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) { v.push_back(i); } int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：accumulate使用时头文件注意是 numeric，这个算法很实用 5.5.2 fill功能描述： 向容器中填充指定的元素 函数原型： fill(iterator beg, iterator end, value); // 向容器中填充元素 // beg 开始迭代器 // end 结束迭代器 // value 填充的值 示例： #include &lt;numeric&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：利用fill可以将容器区间内元素填充为 指定的值 5.6 常用集合算法学习目标： 掌握常用的集合算法 算法简介： set_intersection // 求两个容器的交集 set_union // 求两个容器的并集 set_difference // 求两个容器的差集 ​ 5.6.1 set_intersection功能描述： 求两个容器的交集 函数原型： set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的交集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union功能描述： 求两个集合的并集 函数原型： set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的并集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference功能描述： 求两个集合的差集 函数原型： set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的差集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： #include &lt;vector&gt; #include &lt;algorithm&gt; class myPrint { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; } }; void test01() { vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) { v1.push_back(i); v2.push_back(i+5); } vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 set_difference返回值既是差集中最后一个元素的位置","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第三阶段","slug":"C-教程/C-第三阶段","permalink":"/categories/C-教程/C-第三阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第三阶段","slug":"C-教程/C-第三阶段","permalink":"/categories/C-教程/C-第三阶段/"}]},{"title":"职工管理系统","slug":"职工管理系统","date":"2021-02-03T07:08:26.000Z","updated":"2021-02-03T07:21:05.735Z","comments":true,"path":"2021/02/03/职工管理系统/","link":"","permalink":"/2021/02/03/职工管理系统/","excerpt":"","text":"职工管理系统1、管理系统需求职工管理系统可以用来管理公司内所有员工的信息 本教程主要利用C++来实现一个基于多态的职工管理系统 公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责 普通员工职责：完成经理交给的任务 经理职责：完成老板交给的任务，并下发任务给员工 老板职责：管理公司所有事务 管理系统中需要实现的功能如下： 退出管理程序：退出当前管理系统 增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号 显示职工信息：显示公司内部所有职工的信息 删除离职职工：按照编号删除指定的职工 修改职工信息：按照编号修改职工个人信息 查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息 按照编号排序：按照职工编号，进行排序，排序规则由用户指定 清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删） 系统界面效果图如下： 需根据用户不同的选择，完成不同的功能！ 2、创建项目创建项目步骤如下： 创建新项目 添加文件 2.1 创建项目打开vs2017后，点击创建新项目，创建新的C++项目 填写项目名称以及项目路径，点击确定 2.2 添加文件右键源文件，进行添加文件操作 至此，项目已创建完毕 3、创建管理类​ 管理类负责的内容如下： 与用户的沟通菜单界面 对职工增删改查的操作 与文件的读写交互 3.1创建文件在头文件和源文件的文件夹下分别创建workerManager.h 和 workerManager.cpp文件 3.2 头文件实现在workerManager.h中设计管理类 代码如下： #pragma once #include&lt;iostream&gt; using namespace std; class WorkerManager { public: //构造函数 WorkerManager(); //析构函数 ~WorkerManager(); }; 3.3 源文件实现在workerManager.cpp中将构造和析构函数空实现补全 #include &quot;workerManager.h&quot; WorkerManager::WorkerManager() { } WorkerManager::~WorkerManager() { } 至此职工管理类以创建完毕 4、菜单功能功能描述：与用户的沟通界面 4.1 添加成员函数在管理类workerManager.h中添加成员函数 void Show_Menu(); 4.2 菜单功能实现在管理类workerManager.cpp中实现 Show_Menu()函数 void WorkerManager::Show_Menu() { cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;********* 欢迎使用职工管理系统！ **********&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 0.退出管理程序 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 1.增加职工信息 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 2.显示职工信息 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 3.删除离职职工 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 4.修改职工信息 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 5.查找职工信息 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 6.按照编号排序 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;************* 7.清空所有文档 *************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;********************************************&quot; &lt;&lt; endl; cout &lt;&lt; endl; } 4.3 测试菜单功能在职工管理系统.cpp中测试菜单功能 代码： #include&lt;iostream&gt; using namespace std; #include &quot;workerManager.h&quot; int main() { WorkerManager wm; wm.Show_Menu(); cout &lt;&lt; &quot;请输入您的选择：&quot;&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 运行效果如图： 5、退出功能5.1 提供功能接口在main函数中提供分支选择，提供每个功能接口 代码： int main() { WorkerManager wm; int choice = 0; while (true) { //展示菜单 wm.Show_Menu(); cout &lt;&lt; &quot;请输入您的选择:&quot; &lt;&lt; endl; cin &gt;&gt; choice; switch (choice) { case 0: //退出系统 break; case 1: //添加职工 break; case 2: //显示职工 break; case 3: //删除职工 break; case 4: //修改职工 break; case 5: //查找职工 break; case 6: //排序职工 break; case 7: //清空文件 break; default: system(&quot;cls&quot;); break; } } system(&quot;pause&quot;); return 0; } 5.2 实现退出功能在workerManager.h中提供退出系统的成员函数 void exitSystem(); 在workerManager.cpp中提供具体的功能实现 void WorkerManager::exitSystem() { cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl; system(&quot;pause&quot;); exit(0); } 5.3测试功能在main函数分支 0 选项中，调用退出程序的接口 运行测试效果如图： 6、创建职工类6.1 创建职工抽象类职工的分类为：普通员工、经理、老板 将三种职工抽象到一个类（worker）中,利用多态管理不同职工种类 职工的属性为：职工编号、职工姓名、职工所在部门编号 职工的行为为：岗位职责信息描述，获取岗位名称 头文件文件夹下 创建文件worker.h 文件并且添加如下代码： #pragma once #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //职工抽象基类 class Worker { public: //显示个人信息 virtual void showInfo() = 0; //获取岗位名称 virtual string getDeptName() = 0; int m_Id; //职工编号 string m_Name; //职工姓名 int m_DeptId; //职工所在部门名称编号 }; 6.2 创建普通员工类普通员工类继承职工抽象类，并重写父类中纯虚函数 在头文件和源文件的文件夹下分别创建employee.h 和 employee.cpp文件 employee.h中代码如下： #pragma once #include&lt;iostream&gt; using namespace std; #include &quot;worker.h&quot; //员工类 class Employee :public Worker { public: //构造函数 Employee(int id, string name, int dId); //显示个人信息 virtual void showInfo(); //获取职工岗位名称 virtual string getDeptName(); }; employee.cpp中代码如下： #include &quot;employee.h&quot; Employee::Employee(int id, string name, int dId) { this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } void Employee::showInfo() { cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot; \\t职工姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; \\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot; \\t岗位职责：完成经理交给的任务&quot; &lt;&lt; endl; } string Employee::getDeptName() { return string(&quot;员工&quot;); } 6.3 创建经理类经理类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似 在头文件和源文件的文件夹下分别创建manager.h 和 manager.cpp文件 manager.h中代码如下： #pragma once #include&lt;iostream&gt; using namespace std; #include &quot;worker.h&quot; //经理类 class Manager :public Worker { public: Manager(int id, string name, int dId); //显示个人信息 virtual void showInfo(); //获取职工岗位名称 virtual string getDeptName(); }; manager.cpp中代码如下： #include &quot;manager.h&quot; Manager::Manager(int id, string name, int dId) { this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } void Manager::showInfo() { cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot; \\t职工姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; \\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot; \\t岗位职责：完成老板交给的任务,并下发任务给员工&quot; &lt;&lt; endl; } string Manager::getDeptName() { return string(&quot;经理&quot;); } 6.4 创建老板类老板类继承职工抽象类，并重写父类中纯虚函数，和普通员工类似 在头文件和源文件的文件夹下分别创建boss.h 和 boss.cpp文件 boss.h中代码如下： #pragma once #include&lt;iostream&gt; using namespace std; #include &quot;worker.h&quot; //老板类 class Boss :public Worker { public: Boss(int id, string name, int dId); //显示个人信息 virtual void showInfo(); //获取职工岗位名称 virtual string getDeptName(); }; boss.cpp中代码如下： #include &quot;boss.h&quot; Boss::Boss(int id, string name, int dId) { this-&gt;m_Id = id; this-&gt;m_Name = name; this-&gt;m_DeptId = dId; } void Boss::showInfo() { cout &lt;&lt; &quot;职工编号： &quot; &lt;&lt; this-&gt;m_Id &lt;&lt; &quot; \\t职工姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; \\t岗位：&quot; &lt;&lt; this-&gt;getDeptName() &lt;&lt; &quot; \\t岗位职责：管理公司所有事务&quot; &lt;&lt; endl; } string Boss::getDeptName() { return string(&quot;总裁&quot;); } 6.5 测试多态在职工管理系统.cpp中添加测试函数，并且运行能够产生多态 测试代码如下： #include &quot;worker.h&quot; #include &quot;employee.h&quot; #include &quot;manager.h&quot; #include &quot;boss.h&quot; void test() { Worker * worker = NULL; worker = new Employee(1, &quot;张三&quot;, 1); worker-&gt;showInfo(); delete worker; worker = new Manager(2, &quot;李四&quot;, 2); worker-&gt;showInfo(); delete worker; worker = new Boss(3, &quot;王五&quot;, 3); worker-&gt;showInfo(); delete worker; } 运行效果如图： 测试成功后，测试代码可以注释保留，或者选择删除 7、添加职工功能描述：批量添加职工，并且保存到文件中 7.1 功能分析分析： 用户在批量创建时，可能会创建不同种类的职工 如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里 如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **的指针维护 7.2 功能实现在WokerManager.h头文件中添加成员属性 代码： //记录文件中的人数个数 int m_EmpNum; //员工数组的指针 Worker ** m_EmpArray; 在WorkerManager构造函数中初始化属性 WorkerManager::WorkerManager() { //初始化人数 this-&gt;m_EmpNum = 0; //初始化数组指针 this-&gt;m_EmpArray = NULL; } 在workerManager.h中添加成员函数 //增加职工 void Add_Emp(); workerManager.cpp中实现该函数 //增加职工 void WorkerManager::Add_Emp() { cout &lt;&lt; &quot;请输入增加职工数量： &quot; &lt;&lt; endl; int addNum = 0; cin &gt;&gt; addNum; if (addNum &gt; 0) { //计算新空间大小 int newSize = this-&gt;m_EmpNum + addNum; //开辟新空间 Worker ** newSpace = new Worker*[newSize]; //将原空间下内容存放到新空间下 if (this-&gt;m_EmpArray != NULL) { for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { newSpace[i] = this-&gt;m_EmpArray[i]; } } //输入新数据 for (int i = 0; i &lt; addNum; i++) { int id; string name; int dSelect; cout &lt;&lt; &quot;请输入第 &quot; &lt;&lt; i + 1 &lt;&lt; &quot; 个新职工编号：&quot; &lt;&lt; endl; cin &gt;&gt; id; cout &lt;&lt; &quot;请输入第 &quot; &lt;&lt; i + 1 &lt;&lt; &quot; 个新职工姓名：&quot; &lt;&lt; endl; cin &gt;&gt; name; cout &lt;&lt; &quot;请选择该职工的岗位：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl; cin &gt;&gt; dSelect; Worker * worker = NULL; switch (dSelect) { case 1: //普通员工 worker = new Employee(id, name, 1); break; case 2: //经理 worker = new Manager(id, name, 2); break; case 3: //老板 worker = new Boss(id, name, 3); break; default: break; } newSpace[this-&gt;m_EmpNum + i] = worker; } //释放原有空间 delete[] this-&gt;m_EmpArray; //更改新空间的指向 this-&gt;m_EmpArray = newSpace; //更新新的个数 this-&gt;m_EmpNum = newSize; //提示信息 cout &lt;&lt; &quot;成功添加&quot; &lt;&lt; addNum &lt;&lt; &quot;名新职工！&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 在WorkerManager.cpp的析构函数中，释放堆区数据 WorkerManager::~WorkerManager() { if (this-&gt;m_EmpArray != NULL) { delete[] this-&gt;m_EmpArray; } } 7.3 测试添加在main函数分支 1 选项中，调用添加职工接口 效果如图： 至此，添加职工到程序中功能实现完毕 8、文件交互 - 写文件功能描述：对文件进行读写 ​ 在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了 ​ 因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作 8.1 设定文件路径首先我们将文件路径，在workerManager.h中添加宏常量,并且包含头文件 fstream #include &lt;fstream&gt; #define FILENAME &quot;empFile.txt&quot; 8.2 成员函数声明在workerManager.h中类里添加成员函数 void save() //保存文件 void save(); 8.3 保存文件功能实现void WorkerManager::save() { ofstream ofs; ofs.open(FILENAME, ios::out); for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { ofs &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; &quot; &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl; } ofs.close(); } 8.4 保存文件功能测试在添加职工功能中添加成功后添加保存文件函数 再次运行代码，添加职工 同级目录下多出文件，并且保存了添加的信息 9、文件交互 - 读文件功能描述：将文件中的内容读取到程序中 虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中 而我们的程序功能中还有清空文件的需求 因此构造函数初始化数据的情况分为三种 第一次使用，文件未创建 文件存在，但是数据被用户清空 文件存在，并且保存职工的所有数据 9.1 文件未创建在workerManager.h中添加新的成员属性 m_FileIsEmpty标志文件是否为空 //标志文件是否为空 bool m_FileIsEmpty; 修改WorkerManager.cpp中构造函数代码 WorkerManager::WorkerManager() { ifstream ifs; ifs.open(FILENAME, ios::in); //文件不存在情况 if (!ifs.is_open()) { cout &lt;&lt; &quot;文件不存在&quot; &lt;&lt; endl; //测试输出 this-&gt;m_EmpNum = 0; //初始化人数 this-&gt;m_FileIsEmpty = true; //初始化文件为空标志 this-&gt;m_EmpArray = NULL; //初始化数组 ifs.close(); //关闭文件 return; } } 删除文件后，测试文件不存在时初始化数据功能 9.2 文件存在且数据为空在workerManager.cpp中的构造函数追加代码： //文件存在，并且没有记录 char ch; ifs &gt;&gt; ch; if (ifs.eof()) { cout &lt;&lt; &quot;文件为空!&quot; &lt;&lt; endl; this-&gt;m_EmpNum = 0; this-&gt;m_FileIsEmpty = true; this-&gt;m_EmpArray = NULL; ifs.close(); return; } 追加代码位置如图： 将文件创建后清空文件内容，并测试该情况下初始化功能 我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？ 成功添加职工后，应该更改文件不为空的标志 在void WorkerManager::Add_Emp()成员函数中添加： //更新职工不为空标志 this-&gt;m_FileIsEmpty = false; 9.3 文件存在且保存职工数据9.3.1 获取记录的职工人数在workerManager.h中添加成员函数 int get_EmpNum(); //统计人数 int get_EmpNum(); workerManager.cpp中实现 int WorkerManager::get_EmpNum() { ifstream ifs; ifs.open(FILENAME, ios::in); int id; string name; int dId; int num = 0; while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) { //记录人数 num++; } ifs.close(); return num; } 在workerManager.cpp构造函数中继续追加代码： int num = this-&gt;get_EmpNum(); cout &lt;&lt; &quot;职工个数为：&quot; &lt;&lt; num &lt;&lt; endl; //测试代码 this-&gt;m_EmpNum = num; //更新成员属性 手动添加一些职工数据，测试获取职工数量函数 9.3.2 初始化数组根据职工的数据以及职工数据，初始化workerManager中的Worker ** m_EmpArray 指针 在WorkerManager.h中添加成员函数 void init_Emp(); //初始化员工 void init_Emp(); 在WorkerManager.cpp中实现 void WorkerManager::init_Emp() { ifstream ifs; ifs.open(FILENAME, ios::in); int id; string name; int dId; int index = 0; while (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId) { Worker * worker = NULL; //根据不同的部门Id创建不同对象 if (dId == 1) // 1普通员工 { worker = new Employee(id, name, dId); } else if (dId == 2) //2经理 { worker = new Manager(id, name, dId); } else //总裁 { worker = new Boss(id, name, dId); } //存放在数组中 this-&gt;m_EmpArray[index] = worker; index++; } } 在workerManager.cpp构造函数中追加代码 //根据职工数创建数组 this-&gt;m_EmpArray = new Worker *[this-&gt;m_EmpNum]; //初始化职工 init_Emp(); //测试代码 for (int i = 0; i &lt; m_EmpNum; i++) { cout &lt;&lt; &quot;职工号： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot; 职工姓名： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; &quot; 部门编号： &quot; &lt;&lt; this-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; endl; } 运行程序，测试从文件中获取的数据 至此初始化数据功能完毕，测试代码可以注释或删除掉！ 10、显示职工功能描述：显示当前所有职工信息 10.1 显示职工函数声明在workerManager.h中添加成员函数 void Show_Emp(); //显示职工 void Show_Emp(); 10.2 显示职工函数实现在workerManager.cpp中实现成员函数 void Show_Emp(); //显示职工 void WorkerManager::Show_Emp() { if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl; } else { for (int i = 0; i &lt; m_EmpNum; i++) { //利用多态调用接口 this-&gt;m_EmpArray[i]-&gt;showInfo(); } } system(&quot;pause&quot;); system(&quot;cls&quot;); } 10.3 测试显示职工在main函数分支 2 选项中，调用显示职工接口 测试时分别测试 文件为空和文件不为空两种情况 测试效果： 测试1-文件不存在或者为空情况 测试2 - 文件存在且有记录情况 测试完毕，至此，显示所有职工信息功能实现 11、删除职工功能描述：按照职工的编号进行删除职工操作 11.1 删除职工函数声明在workerManager.h中添加成员函数 void Del_Emp(); //删除职工 void Del_Emp(); 11.2 职工是否存在函数声明很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工 因此添加该公告函数，以便后续调用 在workerManager.h中添加成员函数 int IsExist(int id); //按照职工编号判断职工是否存在,若存在返回职工在数组中位置，不存在返回-1 int IsExist(int id); 11.3 职工是否存在函数实现在workerManager.cpp中实现成员函数 int IsExist(int id); int WorkerManager::IsExist(int id) { int index = -1; for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { if (this-&gt;m_EmpArray[i]-&gt;m_Id == id) { index = i; break; } } return index; } 11.4 删除职工函数实现在workerManager.cpp中实现成员函数 void Del_Emp(); //删除职工 void WorkerManager::Del_Emp() { if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl; } else { //按职工编号删除 cout &lt;&lt; &quot;请输入想要删除的职工号：&quot; &lt;&lt; endl; int id = 0; cin &gt;&gt; id; int index = this-&gt;IsExist(id); if (index != -1) //说明index上位置数据需要删除 { for (int i = index; i &lt; this-&gt;m_EmpNum - 1; i++) { this-&gt;m_EmpArray[i] = this-&gt;m_EmpArray[i + 1]; } this-&gt;m_EmpNum--; this-&gt;save(); //删除后数据同步到文件中 cout &lt;&lt; &quot;删除成功！&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;删除失败，未找到该职工&quot; &lt;&lt; endl; } } system(&quot;pause&quot;); system(&quot;cls&quot;); } 11.5 测试删除职工在main函数分支 3 选项中，调用删除职工接口 测试1 - 删除不存在职工情况 测试2 - 删除存在的职工情况 删除成功提示图： 再次显示所有职工信息，确保已经删除 查看文件中信息，再次核实员工已被完全删除 至此，删除职工功能实现完毕！ 12、修改职工功能描述：能够按照职工的编号对职工信息进行修改并保存 12.1 修改职工函数声明在workerManager.h中添加成员函数 void Mod_Emp(); //修改职工 void Mod_Emp(); 12.2 修改职工函数实现在workerManager.cpp中实现成员函数 void Mod_Emp(); //修改职工 void WorkerManager::Mod_Emp() { if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;请输入修改职工的编号：&quot; &lt;&lt; endl; int id; cin &gt;&gt; id; int ret = this-&gt;IsExist(id); if (ret != -1) { //查找到编号的职工 delete this-&gt;m_EmpArray[ret]; int newId = 0; string newName = &quot;&quot;; int dSelect = 0; cout &lt;&lt; &quot;查到： &quot; &lt;&lt; id &lt;&lt; &quot;号职工，请输入新职工号： &quot; &lt;&lt; endl; cin &gt;&gt; newId; cout &lt;&lt; &quot;请输入新姓名： &quot; &lt;&lt; endl; cin &gt;&gt; newName; cout &lt;&lt; &quot;请输入岗位： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通职工&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、经理&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、老板&quot; &lt;&lt; endl; cin &gt;&gt; dSelect; Worker * worker = NULL; switch (dSelect) { case1: worker = new Employee(newId, newName, dSelect); break; case2: worker = new Manager(newId, newName, dSelect); break; case 3: worker = new Boss(newId, newName, dSelect); break; default: break; } //更改数据 到数组中 this-&gt;m_EmpArray[ret]= worker; cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl; //保存到文件中 this-&gt;save(); } else { cout &lt;&lt; &quot;修改失败，查无此人&quot; &lt;&lt; endl; } } //按任意键 清屏 system(&quot;pause&quot;); system(&quot;cls&quot;); } 12.3 测试修改职工在main函数分支 4 选项中，调用修改职工接口 测试1 - 修改不存在职工情况 测试2 - 修改存在职工情况，例如将职工 “李四” 改为 “赵四” 修改后再次查看所有职工信息，并确认修改成功 再次确认文件中信息也同步更新 至此，修改职工功能已实现！ 13、查找职工功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名 13.1 查找职工函数声明在workerManager.h中添加成员函数 void Find_Emp(); //查找职工 void Find_Emp(); 13.2 查找职工函数实现在workerManager.cpp中实现成员函数 void Find_Emp(); //查找职工 void WorkerManager::Find_Emp() { if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;请输入查找的方式：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、按职工编号查找&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、按姓名查找&quot; &lt;&lt; endl; int select = 0; cin &gt;&gt; select; if (select == 1) //按职工号查找 { int id; cout &lt;&lt; &quot;请输入查找的职工编号：&quot; &lt;&lt; endl; cin &gt;&gt; id; int ret = IsExist(id); if (ret != -1) { cout &lt;&lt; &quot;查找成功！该职工信息如下：&quot; &lt;&lt; endl; this-&gt;m_EmpArray[ret]-&gt;showInfo(); } else { cout &lt;&lt; &quot;查找失败，查无此人&quot; &lt;&lt; endl; } } else if(select == 2) //按姓名查找 { string name; cout &lt;&lt; &quot;请输入查找的姓名：&quot; &lt;&lt; endl; cin &gt;&gt; name; bool flag = false; //查找到的标志 for (int i = 0; i &lt; m_EmpNum; i++) { if (m_EmpArray[i]-&gt;m_Name == name) { cout &lt;&lt; &quot;查找成功,职工编号为：&quot; &lt;&lt; m_EmpArray[i]-&gt;m_Id &lt;&lt; &quot; 号的信息如下：&quot; &lt;&lt; endl; flag = true; this-&gt;m_EmpArray[i]-&gt;showInfo(); } } if (flag == false) { //查无此人 cout &lt;&lt; &quot;查找失败，查无此人&quot; &lt;&lt; endl; } } else { cout &lt;&lt; &quot;输入选项有误&quot; &lt;&lt; endl; } } system(&quot;pause&quot;); system(&quot;cls&quot;); } 13.3 测试查找职工在main函数分支 5 选项中，调用查找职工接口 测试1 - 按照职工编号查找 - 查找不存在职工 测试2 - 按照职工编号查找 - 查找存在职工 测试3 - 按照职工姓名查找 - 查找不存在职工 测试4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工） 例如 添加两个王五的职工，然后按照姓名查找王五 至此，查找职工功能实现完毕！ 14、排序功能描述：按照职工编号进行排序，排序的顺序由用户指定 14.1 排序函数声明在workerManager.h中添加成员函数 void Sort_Emp(); //排序职工 void Sort_Emp(); 14.2 排序函数实现在workerManager.cpp中实现成员函数 void Sort_Emp(); //排序职工 void WorkerManager::Sort_Emp() { if (this-&gt;m_FileIsEmpty) { cout &lt;&lt; &quot;文件不存在或记录为空！&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); } else { cout &lt;&lt; &quot;请选择排序方式： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、按职工号进行升序&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、按职工号进行降序&quot; &lt;&lt; endl; int select = 0; cin &gt;&gt; select; for (int i = 0; i &lt; m_EmpNum; i++) { int minOrMax = i; for (int j = i + 1; j &lt; m_EmpNum; j++) { if (select == 1) //升序 { if (m_EmpArray[minOrMax]-&gt;m_Id &gt; m_EmpArray[j]-&gt;m_Id) { minOrMax = j; } } else //降序 { if (m_EmpArray[minOrMax]-&gt;m_Id &lt; m_EmpArray[j]-&gt;m_Id) { minOrMax = j; } } } if (i != minOrMax) { Worker * temp = m_EmpArray[i]; m_EmpArray[i] = m_EmpArray[minOrMax]; m_EmpArray[minOrMax] = temp; } } cout &lt;&lt; &quot;排序成功,排序后结果为：&quot; &lt;&lt; endl; this-&gt;save(); this-&gt;Show_Emp(); } } 14.3 测试排序功能在main函数分支 6 选项中，调用排序职工接口 测试： 首先我们添加一些职工，序号是无序的，例如： 测试 - 升序排序 文件同步更新 测试 - 降序排序 文件同步更新 至此，职工按照编号排序的功能实现完毕！ 15、清空文件功能描述：将文件中记录数据清空 15.1 清空函数声明在workerManager.h中添加成员函数 void Clean_File(); //清空文件 void Clean_File(); 15.2 清空函数实现在workerManager.cpp中实现员函数 void Clean_File(); //清空文件 void WorkerManager::Clean_File() { cout &lt;&lt; &quot;确认清空？&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、确认&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、返回&quot; &lt;&lt; endl; int select = 0; cin &gt;&gt; select; if (select == 1) { //打开模式 ios::trunc 如果存在删除文件并重新创建 ofstream ofs(FILENAME, ios::trunc); ofs.close(); if (this-&gt;m_EmpArray != NULL) { for (int i = 0; i &lt; this-&gt;m_EmpNum; i++) { if (this-&gt;m_EmpArray[i] != NULL) { delete this-&gt;m_EmpArray[i]; } } this-&gt;m_EmpNum = 0; delete[] this-&gt;m_EmpArray; this-&gt;m_EmpArray = NULL; this-&gt;m_FileIsEmpty = true; } cout &lt;&lt; &quot;清空成功！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 15.3 测试清空文件在main函数分支 7 选项中，调用清空文件接口 测试：确认清空文件 再次查看文件中数据，记录已为空 打开文件，里面数据已确保清空，该功能需要慎用！ 随着清空文件功能实现，本案例制作完毕 ^ _ ^","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第二阶段","slug":"C-教程/C-第二阶段","permalink":"/categories/C-教程/C-第二阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第二阶段","slug":"C-教程/C-第二阶段","permalink":"/categories/C-教程/C-第二阶段/"}]},{"title":"C++核心编程","slug":"C-核心编程","date":"2021-02-03T07:08:10.000Z","updated":"2021-02-03T07:21:05.739Z","comments":true,"path":"2021/02/03/C-核心编程/","link":"","permalink":"/2021/02/03/C-核心编程/","excerpt":"","text":"C++核心编程本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ ==该区域的数据在程序结束后由操作系统释放==. 示例： //全局变量 int g_a = 10; int g_b = 10; //全局常量 const int c_g_a = 10; const int c_g_b = 10; int main() { //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​ 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： int * func() { int a = 10; return &amp;a; } int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ​ 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： int* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​ C++中利用==new==操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== ​ 语法：new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 int* func() { int* a = new int(10); return a; } int main() { int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(&quot;pause&quot;); return 0; } 示例2：开辟数组 //堆区开辟数组 int main() { int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) { arr[i] = i + 100; } for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } //释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0; } 2 引用2.1 引用的基本使用作用： 给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： int main() { int a = 10; int &amp;b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： int main() { int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： //1. 值传递 void mySwap01(int a, int b) { int temp = a; a = b; b = temp; } //2. 地址传递 void mySwap02(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } //3. 引用传递 void mySwap03(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp; } int main() { int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： //返回局部变量引用 int&amp; test01() { int a = 10; //局部变量 return a; } //返回静态变量引用 int&amp; test02() { static int a = 20; return a; } int main() { //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： //发现是引用，转换为 int* const ref = &amp;a; void func(int&amp; ref){ ref = 100; // ref是引用，转换为*ref = 100 } int main(){ int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0; } 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加==const修饰形参==，防止形参改变实参 示例： //引用使用的场景，通常用来修饰形参 void showValue(const int&amp; v) { //v += 10; cout &lt;&lt; v &lt;&lt; endl; } int main() { //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(&quot;pause&quot;); return 0; } 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法：返回值类型 函数名 （参数= 默认值）{} 示例： int func(int a, int b = 10, int c = 10) { return a + b + c; } //1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值 //2. 如果函数声明有默认值，函数实现的时候就不能有默认参数 int func2(int a = 10, int b = 10); int func2(int a, int b) { return a + b; } int main() { cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型){} 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： //函数占位参数 ，占位参数也可以有默认参数 void func(int a, int) { cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl; } int main() { func(10,10); //占位参数必须填补 system(&quot;pause&quot;); return 0; } 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： //函数重载需要函数都在同一个作用域下 void func() { cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl; } void func(int a) { cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl; } void func(double a) { cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl; } void func(int a ,double b) { cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl; } void func(double a ,int b) { cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; } //函数返回值不可以作为函数重载条件 //int func(double a, int b) //{ // cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl; //} int main() { func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(&quot;pause&quot;); return 0; } 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： //函数重载注意事项 //1、引用作为重载条件 void func(int &amp;a) { cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl; } void func(const int &amp;a) { cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl; } //2、函数重载碰到函数默认参数 void func2(int a, int b = 10) { cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl; } void func2(int a) { cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl; } int main() { int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(&quot;pause&quot;); return 0; } 4 类和对象C++面向对象的三大特性为：==封装、继承、多态== C++认为==万事万物都皆为对象==，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​ 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​ 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名{ 访问权限： 属性 / 行为 }; 示例1：设计一个圆类，求圆的周长 示例代码： //圆周率 const double PI = 3.14; //1、封装的意义 //将属性和行为作为一个整体，用来表现生活中的事物 //封装一个圆类，求圆的周长 //class代表设计一个类，后面跟着的是类名 class Circle { public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() { //2 * pi * r //获取圆的周长 return 2 * PI * m_r; } }; int main() { //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： //学生类 class Student { public: void setName(string name) { m_name = name; } void setID(int id) { m_id = id; } void showStudent() { cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; } public: string m_name; int m_id; }; int main() { Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); system(&quot;pause&quot;); return 0; } 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： //三种权限 //公共权限 public 类内可以访问 类外可以访问 //保护权限 protected 类内可以访问 类外不可以访问 //私有权限 private 类内可以访问 类外不可以访问 class Person { //姓名 公共权限 public: string m_Name; //汽车 保护权限 protected: string m_Car; //银行卡密码 私有权限 private: int m_Password; public: void func() { m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; } }; int main() { Person p; p.m_Name = &quot;李四&quot;; //p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(&quot;pause&quot;); return 0; } 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 class C1 { int m_A; //默认是私有权限 }; struct C2 { int m_A; //默认是公共权限 }; int main() { C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(&quot;pause&quot;); return 0; } 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： class Person { public: //姓名设置可读可写 void setName(string name) { m_Name = name; } string getName() { return m_Name; } //获取年龄 int getAge() { return m_Age; } //设置年龄 void setAge(int age) { if (age &lt; 0 || age &gt; 150) { cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; } m_Age = age; } //情人设置为只写 void setLover(string lover) { m_Lover = lover; } private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人 }; int main() { Person p; //姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(&quot;苍井&quot;); //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(&quot;pause&quot;); return 0; } 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​ 一个对象或者变量没有初始状态，对其使用后果是未知 ​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名(){} 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名(){} 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 class Person { public: //构造函数 Person() { cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; } }; void test01() { Person p; } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.2.2 构造函数的分类及调用两种分类方式： ​ 按参数分为： 有参构造和无参构造 ​ 按类型分为： 普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 示例： //1、构造函数分类 // 按照参数分类分为 有参和无参构造 无参又称为默认构造函数 // 按照类型分类分为 普通构造和拷贝构造 class Person { public: //无参（默认）构造函数 Person() { cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; } //有参构造函数 Person(int a) { age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; } //拷贝构造函数 Person(const Person&amp; p) { age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; } public: int age; }; //2、构造函数的调用 //调用无参构造函数 void test01() { Person p; //调用无参构造函数 } //调用有参的构造函数 void test02() { //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4); } int main() { test01(); //test02(); system(&quot;pause&quot;); return 0; } 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： class Person { public: Person() { cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0; } Person(int age) { cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age; } Person(const Person&amp; p) { cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge; } //析构函数在释放内存之前调用 ~Person() { cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; } public: int mAge; }; //1. 使用一个已经创建完毕的对象来初始化一个新对象 void test01() { Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作 } //2. 值传递的方式给函数参数传值 //相当于Person p1 = p; void doWork(Person p1) {} void test02() { Person p; //无参构造函数 doWork(p); } //3. 以值方式返回局部对象 Person doWork2() { Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1; } void test03() { Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl; } int main() { //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0; } 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： class Person { public: //无参（默认）构造函数 Person() { cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; } //有参构造函数 Person(int a) { age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; } //拷贝构造函数 Person(const Person&amp; p) { age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; } //析构函数 ~Person() { cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; } public: int age; }; void test01() { Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl; } void test02() { //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造 } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： class Person { public: //无参（默认）构造函数 Person() { cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; } //有参构造函数 Person(int age ,int height) { cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); } //拷贝构造函数 Person(const Person&amp; p) { cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); } //析构函数 ~Person() { cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) { delete m_height; } } public: int m_age; int* m_height; }; void test01() { Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... {} 示例： class Person { public: ////传统方式初始化 //Person(int a, int b, int c) { // m_A = a; // m_B = b; // m_C = c; //} //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {} void PrintPerson() { cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; } private: int m_A; int m_B; int m_C; }; int main() { Person p(1, 2, 3); p.PrintPerson(); system(&quot;pause&quot;); return 0; } 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： class A {} class B { A a； } B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： class Phone { public: Phone(string name) { m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; } ~Phone() { cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; } string m_PhoneName; }; class Person { public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) { cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; } ~Person() { cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; } void playGame() { cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; } string m_Name; Phone m_Phone; }; void test01() { //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 class Person { public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据 private: static int m_B; //静态成员变量也是有访问权限的 }; int Person::m_A = 10; int Person::m_B = 10; void test01() { //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到 } int main() { test01(); system(&quot;pause&quot;); return 0; } 示例2：静态成员函数 class Person { public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() { cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 } static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() { cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; } }; int Person::m_A = 10; void test01() { //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到 } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 class Person { public: Person() { mA = 0; } //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() { cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; } //静态成员函数也不占对象空间 static void sfunc() { } }; int main() { cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this class Person { public: Person(int age) { //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; } Person&amp; PersonAddPerson(Person p) { this-&gt;age += p.age; //返回对象本身 return *this; } int age; }; void test01() { Person p1(10); cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： //空指针访问成员函数 class Person { public: void ShowClassName() { cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; } void ShowPerson() { if (this == NULL) { return; } cout &lt;&lt; mAge &lt;&lt; endl; } public: int mAge; }; void test01() { Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了 } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： class Person { public: Person() { m_A = 0; m_B = 0; } //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const { //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; } void MyFunc() const { //mA = 10000; } public: int m_A; mutable int m_B; //可修改 可变的 }; //const修饰对象 常对象 void test01() { const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数 } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 ==friend== 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元class Building { //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building); public: Building() { this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; } public: string m_SittingRoom; //客厅 private: string m_BedRoom; //卧室 }; void goodGay(Building * building) { cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void test01() { Building b; goodGay(&amp;b); } int main(){ test01(); system(&quot;pause&quot;); return 0; } 4.4.2 类做友元class Building; class goodGay { public: goodGay(); void visit(); private: Building *building; }; class Building { //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay; public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(&quot;pause&quot;); return 0; } 4.4.3 成员函数做友元 class Building; class goodGay { public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building; }; class Building { //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit(); public: Building(); public: string m_SittingRoom; //客厅 private: string m_BedRoom;//卧室 }; Building::Building() { this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; } goodGay::goodGay() { building = new Building; } void goodGay::visit() { cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void goodGay::visit2() { cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; } void test01() { goodGay gg; gg.visit(); } int main(){ test01(); system(&quot;pause&quot;); return 0; } 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 class Person { public: Person() {}; Person(int a, int b) { this-&gt;m_A = a; this-&gt;m_B = b; } //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) { Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; } public: int m_A; int m_B; }; //全局函数实现 + 号运算符重载 //Person operator+(const Person&amp; p1, const Person&amp; p2) { // Person temp(0, 0); // temp.m_A = p1.m_A + p2.m_A; // temp.m_B = p1.m_B + p2.m_B; // return temp; //} //运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) { Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp; } void test() { Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl; } int main() { test(); system(&quot;pause&quot;); return 0; } 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 class Person { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p); public: Person(int a, int b) { this-&gt;m_A = a; this-&gt;m_B = b; } //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p){ //} private: int m_A; int m_B; }; //全局函数实现左移重载 //ostream对象只能有一个 ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) { out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out; } void test() { Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程 } int main() { test(); system(&quot;pause&quot;); return 0; } 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 class MyInteger { friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint); public: MyInteger() { m_Num = 0; } //前置++ MyInteger&amp; operator++() { //先++ m_Num++; //再返回 return *this; } //后置++ MyInteger operator++(int) { //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; } private: int m_Num; }; ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) { out &lt;&lt; myint.m_Num; return out; } //前置++ 先++ 再返回 void test01() { MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; } //后置++ 先返回 再++ void test02() { MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl; } int main() { test01(); //test02(); system(&quot;pause&quot;); return 0; } 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： class Person { public: Person(int age) { //将年龄数据开辟到堆区 m_Age = new int(age); } //重载赋值运算符 Person&amp; operator=(Person &amp;p) { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; } ~Person() { if (m_Age != NULL) { delete m_Age; m_Age = NULL; } } //年龄的指针 int *m_Age; }; void test01() { Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl; } int main() { test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： class Person { public: Person(string name, int age) { this-&gt;m_Name = name; this-&gt;m_Age = age; }; bool operator==(Person &amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return true; } else { return false; } } bool operator!=(Person &amp; p) { if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) { return false; } else { return true; } } string m_Name; int m_Age; }; void test01() { //int a = 0; //int b = 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a == b) { cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; } if (a != b) { cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; } } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： class MyPrint { public: void operator()(string text) { cout &lt;&lt; text &lt;&lt; endl; } }; void test01() { //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;); } class MyAdd { public: int operator()(int v1, int v2) { return v1 + v2; } }; void test02() { MyAdd add; int ret = add(10, 10); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl; } int main() { test01(); test02(); system(&quot;pause&quot;); return 0; } 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： //Java页面 class Java { public: void header() { cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; } void footer() { cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; } void left() { cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; } void content() { cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; } }; //Python页面 class Python { public: void header() { cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; } void footer() { cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; } void left() { cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; } void content() { cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; } }; //C++页面 class CPP { public: void header() { cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; } void footer() { cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; } void left() { cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; } void content() { cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; } }; void test01() { //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 继承实现： //公共页面 class BasePage { public: void header() { cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; } void footer() { cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; } void left() { cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; } }; //Java页面 class Java : public BasePage { public: void content() { cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; } }; //Python页面 class Python : public BasePage { public: void content() { cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; } }; //C++页面 class CPP : public BasePage { public: void content() { cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; } }; void test01() { //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 继承的好处：==可以减少重复的代码== class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： class Base1 { public: int m_A; protected: int m_B; private: int m_C; }; //公共继承 class Son1 :public Base1 { public: void func() { m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 } }; void myClass() { Son1 s1; s1.m_A; //其他类只能访问到公共权限 } //保护继承 class Base2 { public: int m_A; protected: int m_B; private: int m_C; }; class Son2:protected Base2 { public: void func() { m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 } }; void myClass2() { Son2 s; //s.m_A; //不可访问 } //私有继承 class Base3 { public: int m_A; protected: int m_B; private: int m_C; }; class Son3:private Base3 { public: void func() { m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 } }; class GrandSon3 :public Son3 { public: void func() { //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; } }; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： class Base { public: int m_A; protected: int m_B; private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去 }; //公共继承 class Son :public Base { public: int m_D; }; void test01() { cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： class Base { public: Base() { cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; } ~Base() { cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; } }; class Son : public Base { public: Son() { cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; } ~Son() { cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; } }; void test01() { //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base { public: Base() { m_A = 100; } void func() { cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; } void func(int a) { cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; } public: int m_A; }; class Son : public Base { public: Son() { m_A = 200; } //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() { cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; } public: int m_A; }; void test01() { Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10); } int main() { test01(); system(&quot;pause&quot;); return EXIT_SUCCESS; } 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： class Base { public: static void func() { cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; } static void func(int a) { cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; } static int m_A; }; int Base::m_A = 100; class Son : public Base { public: static void func() { cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; } static int m_A; }; int Son::m_A = 200; //同名成员属性 void test01() { //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl; } //同名成员函数 void test02() { //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100); } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： class Base1 { public: Base1() { m_A = 100; } public: int m_A; }; class Base2 { public: Base2() { m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 } public: int m_A; }; //语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 { public: Son() { m_C = 300; m_D = 400; } public: int m_C; int m_D; }; //多继承容易产生成员同名的情况 //通过使用类名作用域可以区分调用哪一个基类的成员 void test01() { Son s; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： class Animal { public: int m_Age; }; //继承前加virtual关键字后，变为虚继承 //此时公共的父类Animal称为虚基类 class Sheep : virtual public Animal {}; class Tuo : virtual public Animal {}; class SheepTuo : public Sheep, public Tuo {}; void test01() { SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 class Animal { public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() { cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; } }; class Cat :public Animal { public: void speak() { cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; } }; class Dog :public Animal { public: void speak() { cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; } }; //我们希望传入什么对象，那么就调用什么对象的函数 //如果函数地址在编译阶段就能确定，那么静态联编 //如果函数地址在运行阶段才能确定，就是动态联编 void DoSpeak(Animal &amp; animal) { animal.speak(); } // //多态满足条件： //1、有继承关系 //2、子类重写父类中的虚函数 //多态使用： //父类指针或引用指向子类对象 void test01() { Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： //普通实现 class Calculator { public: int getResult(string oper) { if (oper == &quot;+&quot;) { return m_Num1 + m_Num2; } else if (oper == &quot;-&quot;) { return m_Num1 - m_Num2; } else if (oper == &quot;*&quot;) { return m_Num1 * m_Num2; } //如果要提供新的运算，需要修改源码 } public: int m_Num1; int m_Num2; }; void test01() { //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; } //多态实现 //抽象计算器类 //多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护 class AbstractCalculator { public : virtual int getResult() { return 0; } int m_Num1; int m_Num2; }; //加法计算器 class AddCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 + m_Num2; } }; //减法计算器 class SubCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 - m_Num2; } }; //乘法计算器 class MulCalculator :public AbstractCalculator { public: int getResult() { return m_Num1 * m_Num2; } }; void test02() { //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; } int main() { //test01(); test02(); system(&quot;pause&quot;); return 0; } 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为==抽象类== 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： class Base { public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0; }; class Son :public Base { public: virtual void func() { cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; }; }; void test01() { Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁 } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： //抽象制作饮品 class AbstractDrinking { public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() { Boil(); Brew(); PourInCup(); PutSomething(); } }; //制作咖啡 class Coffee : public AbstractDrinking { public: //烧水 virtual void Boil() { cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; } }; //制作茶水 class Tea : public AbstractDrinking { public: //烧水 virtual void Boil() { cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; } //冲泡 virtual void Brew() { cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; } //倒入杯中 virtual void PourInCup() { cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; } }; //业务函数 void DoWork(AbstractDrinking* drink) { drink-&gt;MakeDrink(); delete drink; } void test01() { DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea); } int main() { test01(); system(&quot;pause&quot;); return 0; } 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名(){} 纯虚析构语法： virtual ~类名() = 0; 类名::~类名(){} 示例： class Animal { public: Animal() { cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; } virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //{ // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //} virtual ~Animal() = 0; }; Animal::~Animal() { cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl; } //和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。 class Cat : public Animal { public: Cat(string name) { cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name); } virtual void Speak() { cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; } ~Cat() { cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) { delete m_Name; m_Name = NULL; } } public: string *m_Name; }; void test01() { Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal; } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： ​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​ 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： #include&lt;iostream&gt; using namespace std; //抽象CPU类 class CPU { public: //抽象的计算函数 virtual void calculate() = 0; }; //抽象显卡类 class VideoCard { public: //抽象的显示函数 virtual void display() = 0; }; //抽象内存条类 class Memory { public: //抽象的存储函数 virtual void storage() = 0; }; //电脑类 class Computer { public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) { m_cpu = cpu; m_vc = vc; m_mem = mem; } //提供工作的函数 void work() { //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); } //提供析构函数 释放3个电脑零件 ~Computer() { //释放CPU零件 if (m_cpu != NULL) { delete m_cpu; m_cpu = NULL; } //释放显卡零件 if (m_vc != NULL) { delete m_vc; m_vc = NULL; } //释放内存条零件 if (m_mem != NULL) { delete m_mem; m_mem = NULL; } } private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针 }; //具体厂商 //Intel厂商 class IntelCPU :public CPU { public: virtual void calculate() { cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; } }; class IntelVideoCard :public VideoCard { public: virtual void display() { cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; } }; class IntelMemory :public Memory { public: virtual void storage() { cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; } }; //Lenovo厂商 class LenovoCPU :public CPU { public: virtual void calculate() { cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; } }; class LenovoVideoCard :public VideoCard { public: virtual void display() { cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; } }; class LenovoMemory :public Memory { public: virtual void storage() { cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; } }; void test01() { //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3; } 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 ==&lt; fstream &gt;== 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream> 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); ​ 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： #include &lt;fstream&gt; void test01() { ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream> 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： #include &lt;fstream&gt; #include &lt;string&gt; void test01() { ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; } //第一种方式 //char buf[1024] = { 0 }; //while (ifs &gt;&gt; buf) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} //第二种 //char buf[1024] = { 0 }; //while (ifs.getline(buf,sizeof(buf))) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} //第三种 //string buf; //while (getline(ifs, buf)) //{ // cout &lt;&lt; buf &lt;&lt; endl; //} char c; while ((c = ifs.get()) != EOF) { cout &lt;&lt; c; } ifs.close(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 ==ios::binary== 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person { public: char m_Name[64]; int m_Age; }; //二进制文件 写文件 void test01() { //1、包含头文件 //2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件 //ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p = {&quot;张三&quot; , 18}; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close(); } int main() { test01(); system(&quot;pause&quot;); return 0; } 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： #include &lt;fstream&gt; #include &lt;string&gt; class Person { public: char m_Name[64]; int m_Age; }; void test01() { ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) { cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; } Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; } int main() { test01(); system(&quot;pause&quot;); return 0; } 文件输入流对象 可以通过read函数，以二进制方式读数据","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第二阶段","slug":"C-教程/C-第二阶段","permalink":"/categories/C-教程/C-第二阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第二阶段","slug":"C-教程/C-第二阶段","permalink":"/categories/C-教程/C-第二阶段/"}]},{"title":"C++基础入门（第一阶段）","slug":"C-基础入门（第一阶段）","date":"2021-02-02T16:14:00.000Z","updated":"2021-02-02T16:42:50.610Z","comments":true,"path":"2021/02/03/C-基础入门（第一阶段）/","link":"","permalink":"/2021/02/03/C-基础入门（第一阶段）/","excerpt":"","text":"C++基础入门1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码#include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &quot;Hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： #include&lt;iostream&gt; using namespace std; int main() { //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 ==通常在文件上方定义==，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 ==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改 示例： //1、宏常量 #define day 7 int main() { cout &lt;&lt; &quot;一周里总共有 &quot; &lt;&lt; day &lt;&lt; &quot; 天&quot; &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; &quot;一年里总共有 &quot; &lt;&lt; month &lt;&lt; &quot; 个月份&quot; &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(&quot;pause&quot;); return 0; } 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以==统计数据类型所占内存大小== 语法： sizeof( 数据类型 / 变量) 示例： int main() { cout &lt;&lt; &quot;short 类型所占内存空间为： &quot; &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; &quot;int 类型所占内存空间为： &quot; &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; &quot;long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; &quot;long long 类型所占内存空间为： &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 整型结论：==short &lt; int &lt;= long &lt;= long long== 2.3 实型（浮点型）作用：用于==表示小数== 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： int main() { float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; &quot;float sizeof = &quot; &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; &quot;double sizeof = &quot; &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; &quot;f2 = &quot; &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; &quot;f3 = &quot; &lt;&lt; f3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = &#39;a&#39;; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用==1个字节==。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： int main() { char ch = &#39;a&#39;; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = &quot;abcde&quot;; //错误，不可以用双引号 //ch = &#39;abcde&#39;; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 \\ 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些==不能显示出来的ASCII字符== 现阶段我们常用的转义字符有：\\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符”\\” 092 \\’ 代表一个单引号（撇号）字符 039 \\” 代表一个双引号字符 034 \\? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围0~9，a~f，A~F 3位16进制 示例： int main() { cout &lt;&lt; &quot;\\\\&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\tHello&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： int main() { char str1[] = &quot;hello world&quot;; cout &lt;&lt; str1 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： int main() { string str = &quot;hello world&quot;; cout &lt;&lt; str &lt;&lt; endl; system(&quot;pause&quot;); return 0; } ​ 注意：C++风格字符串，需要加入头文件==#include\\== 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占==1个字节==大小 示例： int main() { bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; &quot;size of bool = &quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(&quot;pause&quot;); return 0; } 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： int main(){ //整型输入 int a = 0; cout &lt;&lt; &quot;请输入整型变量：&quot; &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; &quot;请输入浮点型变量：&quot; &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; &quot;请输入字符型变量：&quot; &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; &quot;请输入字符串型变量：&quot; &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; &quot;请输入布尔型变量：&quot; &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(&quot;pause&quot;); return EXIT_SUCCESS; } 3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： //加减乘除 int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：在除法运算中，除数不能为0 示例2： //取模 int main() { int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：只有整型变量可以进行取模运算 示例3： //递增 int main() { //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： int main() { //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 > 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 >= 大于等于 4 &gt;= 1 1 示例： int main() { int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0; } 注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示， “假”用数字“0”来表示。== 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 \\ \\ 或 a \\ \\ b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 //逻辑运算符 --- 非 int main() { int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(&quot;pause&quot;); return 0; } 总结： 真变假，假变真 示例2：逻辑与 //逻辑运算符 --- 与 int main() { int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0; } 总结：逻辑==与==运算符总结： ==同真为真，其余为假== 示例3：逻辑或 //逻辑运算符 --- 或 int main() { int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(&quot;pause&quot;); return 0; } 逻辑==或==运算符总结： ==同假为假，其余为真== 4 程序流程结构C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构== 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 ​ 单行格式if语句：if(条件){ 条件满足执行的语句 } 示例： int main() { //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; &quot;请输入一个分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; &quot;您输入的分数为： &quot; &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学！！！&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } ​ 注意：if条件表达式后不要加分号 多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; ​ 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上一本大学&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} ​ ​ ​ 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } ​ 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： int main() { int score = 0; cout &lt;&lt; &quot;请输入考试分数：&quot; &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) { cout &lt;&lt; &quot;我考上了一本大学&quot; &lt;&lt; endl; if (score &gt; 700) { cout &lt;&lt; &quot;我考上了北大&quot; &lt;&lt; endl; } else if (score &gt; 650) { cout &lt;&lt; &quot;我考上了清华&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我考上了人大&quot; &lt;&lt; endl; } } else if (score &gt; 500) { cout &lt;&lt; &quot;我考上了二本大学&quot; &lt;&lt; endl; } else if (score &gt; 400) { cout &lt;&lt; &quot;我考上了三本大学&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;我未考上本科&quot; &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 练习案例： 三只小猪称体重 有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？ 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： int main() { int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： switch(表达式) { case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break; } 示例： int main() { //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; &quot;请给电影打分&quot; &lt;&lt; endl; cin &gt;&gt; score; switch (score) { case 10: case 9: cout &lt;&lt; &quot;经典&quot; &lt;&lt; endl; break; case 8: cout &lt;&lt; &quot;非常好&quot; &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; &quot;一般&quot; &lt;&lt; endl; break; default: cout &lt;&lt; &quot;烂片&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0; } 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法：while(循环条件){ 循环语句 } 解释：==只要循环条件的结果为真，就执行循环语句== 示例： int main() { int num = 0; while (num &lt; 10) { cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl; num++; } system(&quot;pause&quot;); return 0; } 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例：==猜数字== 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do{ 循环语句 } while(循环条件); 注意：与while的区别在于==do…while会先执行一次循环语句==，再判断循环条件 示例： int main() { int num = 0; do { cout &lt;&lt; num &lt;&lt; endl; num++; } while (num &lt; 10); system(&quot;pause&quot;); return 0; } 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： int main() { for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： int main() { //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句4.3.1 break语句作用: 用于跳出==选择结构==或者==循环结构== break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： int main() { //1、在switch 语句中使用break cout &lt;&lt; &quot;请选择您挑战副本的难度：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1、普通&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2、中等&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3、困难&quot; &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) { case 1: cout &lt;&lt; &quot;您选择的是普通难度&quot; &lt;&lt; endl; break; case 2: cout &lt;&lt; &quot;您选择的是中等难度&quot; &lt;&lt; endl; break; case 3: cout &lt;&lt; &quot;您选择的是困难难度&quot; &lt;&lt; endl; break; } system(&quot;pause&quot;); return 0; } 示例2： int main() { //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) { if (i == 5) { break; //跳出循环语句 } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 示例3： int main() { //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { if (j == 5) { break; } cout &lt;&lt; &quot;*&quot; &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 4.3.2 continue语句作用：在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： int main() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { continue; } cout &lt;&lt; i &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： int main() { cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; goto FLAG; cout &lt;&lt; &quot;2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;3&quot; &lt;&lt; endl; cout &lt;&lt; &quot;4&quot; &lt;&lt; endl; FLAG: cout &lt;&lt; &quot;5&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个==数据元素都是相同的数据类型== 特点2：数组是由==连续的内存==位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例 int main() { //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = {值1，值2 ，值3 ...}; //如果{}内不足10个数据，剩余数据用0补全 int score2[10] = { 100, 90,80,70,60,50,40,30,20,10 }; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score2[i] &lt;&lt; endl; } //定义方式3 //数据类型 数组名[] = {值1，值2 ，值3 ...}; int score3[] = { 100,90,80,70,60,50,40,30,20,10 }; for (int i = 0; i &lt; 10; i++) { cout &lt;&lt; score3[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： int main() { //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout &lt;&lt; &quot;整个数组所占内存空间为： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;每个元素所占内存空间为： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;数组的元素个数为： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; &quot;数组首地址为： &quot; &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; &quot;数组中第一个元素地址为： &quot; &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;数组中第二个元素地址为： &quot; &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(&quot;pause&quot;); return 0; } 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重 案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 练习案例2：数组元素逆置 案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 int main() { int arr[9] = { 4,2,8,0,5,7,1,3,9 }; for (int i = 0; i &lt; 9 - 1; i++) { for (int j = 0; j &lt; 9 - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt; 9; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性== 示例： int main() { //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 3; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } //方式2 //数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 } }; int arr2[2][3] = { {1,2,3}, {4,5,6} }; //方式3 //数据类型 数组名[行数][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr3[2][3] = { 1,2,3,4,5,6 }; //方式4 //数据类型 数组名[][列数] = { 数据1，数据2 ,数据3，数据4 }; int arr4[][3] = { 1,2,3,4,5,6 }; system(&quot;pause&quot;); return 0; } 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： int main() { //二维数组数组名 int arr[2][3] = { {1,2,3}, {4,5,6} }; cout &lt;&lt; &quot;二维数组大小： &quot; &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组一行大小： &quot; &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组元素大小： &quot; &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组行数： &quot; &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; &quot;二维数组列数： &quot; &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; &quot;二维数组首地址：&quot; &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一行地址：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二行地址：&quot; &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第一个元素地址：&quot; &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; &quot;二维数组第二个元素地址：&quot; &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： int main() { int scores[3][3] = { {100,100,100}, {90,50,100}, {60,70,80}, }; string names[3] = { &quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot; }; for (int i = 0; i &lt; 3; i++) { int sum = 0; for (int j = 0; j &lt; 3; j++) { sum += scores[i][j]; } cout &lt;&lt; names[i] &lt;&lt; &quot;同学总成绩为： &quot; &lt;&lt; sum &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 返回值类型 函数名 （参数列表） { 函数体语句 return表达式 } 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 //函数定义 int add(int num1, int num2) { int sum = num1 + num2; return sum; } 6.3 函数的调用功能：使用定义好的函数 语法：函数名（参数） 示例： //函数定义 int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参 { int sum = num1 + num2; return sum; } int main() { int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，==如果形参发生，并不会影响实参== 示例： void swap(int num1, int num2) { cout &lt;&lt; &quot;交换前：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; &quot;交换后：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;num1 = &quot; &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; &quot;num2 = &quot; &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return } int main() { int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;mian中的 a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;mian中的 b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： //函数常见样式 //1、 无参无返 void test01() { //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; &quot;this is test01&quot; &lt;&lt; endl; //test01(); 函数调用 } //2、 有参无返 void test02(int a) { cout &lt;&lt; &quot;this is test02&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; } //3、无参有返 int test03() { cout &lt;&lt; &quot;this is test03 &quot; &lt;&lt; endl; return 10; } //4、有参有返 int test04(int a, int b) { cout &lt;&lt; &quot;this is test04 &quot; &lt;&lt; endl; int sum = a + b; return sum; } 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： //声明可以多次，定义只能一次 //声明 int max(int a, int b); int max(int a, int b); //定义 int max(int a, int b) { return a &gt; b ? a : b; } int main() { int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： //swap.h文件 #include&lt;iostream&gt; using namespace std; //实现两个数字交换的函数声明 void swap(int a, int b); //swap.cpp文件 #include &quot;swap.h&quot; void swap(int a, int b) { int temp = a; a = b; b = temp; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; } //main函数文件 #include &quot;swap.h&quot; int main() { int a = 100; int b = 200; swap(a, b); system(&quot;pause&quot;); return 0; } 7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 ​ 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： int main() { //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： int main() { int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 int main() { //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 野指针：指针变量指向非法的内存空间 示例2：野指针 int main() { //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： int main() { int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(&quot;pause&quot;); return 0; } 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; int * p = arr; //指向数组的指针 cout &lt;&lt; &quot;第一个元素： &quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素： &quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) { //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; } system(&quot;pause&quot;); return 0; } 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： //值传递 void swap1(int a ,int b) { int temp = a; a = b; b = temp; } //地址传递 void swap2(int * p1, int *p2) { int temp = *p1; *p1 = *p2; *p2 = temp; } int main() { int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： //冒泡排序函数 void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[] { for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组函数 void printArray(int arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; arr[i] &lt;&lt; endl; } } int main() { int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(&quot;pause&quot;); return 0; } 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体8.1 结构体基本概念结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 { 结构体成员列表 }； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }stu3; //结构体变量创建方式3 int main() { //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = &quot;张三&quot;; stu1.age = 18; stu1.score = 100; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu1.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu1.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = { &quot;李四&quot;,19,60 }; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu2.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu2.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = &quot;王五&quot;; stu3.age = 18; stu3.score = 80; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu3.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu3.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu3.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体名 数组名[元素个数] = { {} , {} , ... {} } 示例： //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 } int main() { //结构体数组 struct student arr[3]= { {&quot;张三&quot;,18,80 }, {&quot;李四&quot;,19,60 }, {&quot;王五&quot;,20,70 } }; for (int i = 0; i &lt; 3; i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; arr[i].age &lt;&lt; &quot; 分数：&quot; &lt;&lt; arr[i].score &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 示例： //结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; int main() { struct student stu = { &quot;张三&quot;,18,100, }; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //教师结构体定义 struct teacher { //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生 }; int main() { struct teacher t1; t1.id = 10000; t1.name = &quot;老王&quot;; t1.age = 40; t1.stu.name = &quot;张三&quot;; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; &quot;教师 职工编号： &quot; &lt;&lt; t1.id &lt;&lt; &quot; 姓名： &quot; &lt;&lt; t1.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; &quot;辅导学员 姓名： &quot; &lt;&lt; t1.stu.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; t1.stu.age &lt;&lt; &quot; 考试分数： &quot; &lt;&lt; t1.stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //值传递 void printStudent(student stu ) { stu.age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; } //地址传递 void printStudent2(student *stu) { stu-&gt;age = 28; cout &lt;&lt; &quot;子函数中 姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; } int main() { student stu = { &quot;张三&quot;,18,100}; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： //学生结构体定义 struct student { //成员列表 string name; //姓名 int age; //年龄 int score; //分数 }; //const使用场景 void printStudent(const student *stu) //加const防止函数体中的误操作 { //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl; } int main() { student stu = { &quot;张三&quot;,18,100 }; printStudent(&amp;stu); system(&quot;pause&quot;); return 0; } 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： struct Student { string name; int score; }; struct Teacher { string name; Student sArray[5]; }; void allocateSpace(Teacher tArray[] , int len) { string tName = &quot;教师&quot;; string sName = &quot;学生&quot;; string nameSeed = &quot;ABCDE&quot;; for (int i = 0; i &lt; len; i++) { tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) { tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; } } } void printTeachers(Teacher tArray[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) { cout &lt;&lt; &quot;\\t姓名：&quot; &lt;&lt; tArray[i].sArray[j].name &lt;&lt; &quot; 分数：&quot; &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; } } } int main() { srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(&quot;pause&quot;); return 0; } 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, 示例： //英雄结构体 struct hero { string name; int age; string sex; }; //冒泡排序 void bubbleSort(hero arr[] , int len) { for (int i = 0; i &lt; len - 1; i++) { for (int j = 0; j &lt; len - 1 - i; j++) { if (arr[j].age &gt; arr[j + 1].age) { hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } //打印数组 void printHeros(hero arr[], int len) { for (int i = 0; i &lt; len; i++) { cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].name &lt;&lt; &quot; 性别： &quot; &lt;&lt; arr[i].sex &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].age &lt;&lt; endl; } } int main() { struct hero arr[5] = { {&quot;刘备&quot;,23,&quot;男&quot;}, {&quot;关羽&quot;,22,&quot;男&quot;}, {&quot;张飞&quot;,20,&quot;男&quot;}, {&quot;赵云&quot;,21,&quot;男&quot;}, {&quot;貂蝉&quot;,19,&quot;女&quot;}, }; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(&quot;pause&quot;); return 0; } #","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第一阶段","slug":"C-教程/C-第一阶段","permalink":"/categories/C-教程/C-第一阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第一阶段","slug":"C-教程/C-第一阶段","permalink":"/categories/C-教程/C-第一阶段/"}]},{"title":"通讯录管理系统","slug":"通讯录管理系统","date":"2021-02-02T16:08:11.000Z","updated":"2021-02-02T16:43:14.404Z","comments":true,"path":"2021/02/03/通讯录管理系统/","link":"","permalink":"/2021/02/03/通讯录管理系统/","excerpt":"","text":"通讯录管理系统1、系统需求通讯录是一个可以记录亲人、好友信息的工具。 本教程主要利用C++来实现一个通讯录管理系统 系统中需要实现的功能如下： 添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址）最多记录1000人 显示联系人：显示通讯录中所有联系人信息 删除联系人：按照姓名进行删除指定联系人 查找联系人：按照姓名查看指定联系人信息 修改联系人：按照姓名重新修改指定联系人 清空联系人：清空通讯录中所有信息 退出通讯录：退出当前使用的通讯录 2、创建项目创建项目步骤如下： 创建新项目 添加文件 2.1 创建项目打开vs2017后，点击创建新项目，创建新的C++项目 填写项目名称，选择项目路径 2.2添加文件 添加成功后，效果如图： 至此，项目已创建完毕 3、菜单功能功能描述： 用户选择功能的界面 菜单界面效果如下图： 步骤： 封装函数显示该界面 如 void showMenu() 在main函数中调用封装好的函数 代码： #include&lt;iostream&gt; using namespace std; //菜单界面 void showMenu() { cout &lt;&lt; &quot;***************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 1、添加联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 2、显示联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 3、删除联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 4、查找联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 5、修改联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 6、清空联系人 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***** 0、退出通讯录 *****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***************************&quot; &lt;&lt; endl; } int main() { showMenu(); system(&quot;pause&quot;); return 0; } 4、退出功能功能描述：退出通讯录系统 思路：根据用户不同的选择，进入不同的功能，可以选择switch分支结构，将整个架构进行搭建 当用户选择0时候，执行退出，选择其他先不做操作，也不会退出程序 代码： int main() { int select = 0; while (true) { showMenu(); cin &gt;&gt; select; switch (select) { case 1: //添加联系人 break; case 2: //显示联系人 break; case 3: //删除联系人 break; case 4: //查找联系人 break; case 5: //修改联系人 break; case 6: //清空联系人 break; case 0: //退出通讯录 cout &lt;&lt; &quot;欢迎下次使用&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; break; default: break; } } system(&quot;pause&quot;); return 0; } 效果图： 5、添加联系人功能描述： 实现添加联系人功能，联系人上限为1000人，联系人信息包括（姓名、性别、年龄、联系电话、家庭住址） 添加联系人实现步骤： 设计联系人结构体 设计通讯录结构体 main函数中创建通讯录 封装添加联系人函数 测试添加联系人功能 5.1 设计联系人结构体联系人信息包括：姓名、性别、年龄、联系电话、家庭住址 设计如下： #include &lt;string&gt; //string头文件 //联系人结构体 struct Person { string m_Name; //姓名 int m_Sex; //性别：1男 2女 int m_Age; //年龄 string m_Phone; //电话 string m_Addr; //住址 }; 5.2 设计通讯录结构体设计时候可以在通讯录结构体中，维护一个容量为1000的存放联系人的数组，并记录当前通讯录中联系人数量 设计如下 #define MAX 1000 //最大人数 //通讯录结构体 struct Addressbooks { struct Person personArray[MAX]; //通讯录中保存的联系人数组 int m_Size; //通讯录中人员个数 }; 5.3 main函数中创建通讯录添加联系人函数封装好后，在main函数中创建一个通讯录变量，这个就是我们需要一直维护的通讯录 mian函数起始位置添加： //创建通讯录 Addressbooks abs; //初始化通讯录中人数 abs.m_Size = 0; 5.4 封装添加联系人函数思路：添加联系人前先判断通讯录是否已满，如果满了就不再添加，未满情况将新联系人信息逐个加入到通讯录 添加联系人代码： //1、添加联系人信息 void addPerson(Addressbooks *abs) { //判断电话本是否满了 if (abs-&gt;m_Size == MAX) { cout &lt;&lt; &quot;通讯录已满，无法添加&quot; &lt;&lt; endl; return; } else { //姓名 string name; cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[abs-&gt;m_Size].m_Name = name; cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl; //性别 int sex = 0; while (true) { cin &gt;&gt; sex; if (sex == 1 || sex == 2) { abs-&gt;personArray[abs-&gt;m_Size].m_Sex = sex; break; } cout &lt;&lt; &quot;输入有误，请重新输入&quot;; } //年龄 cout &lt;&lt; &quot;请输入年龄：&quot; &lt;&lt; endl; int age = 0; cin &gt;&gt; age; abs-&gt;personArray[abs-&gt;m_Size].m_Age = age; //联系电话 cout &lt;&lt; &quot;请输入联系电话：&quot; &lt;&lt; endl; string phone = &quot;&quot;; cin &gt;&gt; phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone = phone; //家庭住址 cout &lt;&lt; &quot;请输入家庭住址：&quot; &lt;&lt; endl; string address; cin &gt;&gt; address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr = address; //更新通讯录人数 abs-&gt;m_Size++; cout &lt;&lt; &quot;添加成功&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); } } 5.5 测试添加联系人功能选择界面中，如果玩家选择了1，代表添加联系人，我们可以测试下该功能 在switch case 语句中，case1里添加： case 1: //添加联系人 addPerson(&amp;abs); break; 测试效果如图： 6、显示联系人功能描述：显示通讯录中已有的联系人信息 显示联系人实现步骤： 封装显示联系人函数 测试显示联系人功能 6.1 封装显示联系人函数思路：判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中信息 显示联系人代码： //2、显示所有联系人信息 void showPerson(Addressbooks * abs) { if (abs-&gt;m_Size == 0) { cout &lt;&lt; &quot;当前记录为空&quot; &lt;&lt; endl; } else { for (int i = 0; i &lt; abs-&gt;m_Size; i++) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[i].m_Name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;性别：&quot; &lt;&lt; (abs-&gt;personArray[i].m_Sex == 1 ? &quot;男&quot; : &quot;女&quot;) &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[i].m_Age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[i].m_Phone &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;住址：&quot; &lt;&lt; abs-&gt;personArray[i].m_Addr &lt;&lt; endl; } } system(&quot;pause&quot;); system(&quot;cls&quot;); } 6.2 测试显示联系人功能在switch case语句中，case 2 里添加 case 2: //显示联系人 showPerson(&amp;abs); break; 测试效果如图： 7、删除联系人功能描述：按照姓名进行删除指定联系人 删除联系人实现步骤： 封装检测联系人是否存在 封装删除联系人函数 测试删除联系人功能 7.1 封装检测联系人是否存在设计思路： 删除联系人前，我们需要先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人 因此我们可以把检测联系人是否存在封装成一个函数中，如果存在，返回联系人在通讯录中的位置，不存在返回-1 检测联系人是否存在代码： //判断是否存在查询的人员，存在返回在数组中索引位置，不存在返回-1 int isExist(Addressbooks * abs, string name) { for (int i = 0; i &lt; abs-&gt;m_Size; i++) { if (abs-&gt;personArray[i].m_Name == name) { return i; } } return -1; } 7.2 封装删除联系人函数根据用户输入的联系人判断该通讯录中是否有此人 查找到进行删除，并提示删除成功 查不到提示查无此人。 //3、删除指定联系人信息 void deletePerson(Addressbooks * abs) { cout &lt;&lt; &quot;请输入您要删除的联系人&quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) { for (int i = ret; i &lt; abs-&gt;m_Size; i++) { abs-&gt;personArray[i] = abs-&gt;personArray[i + 1]; } abs-&gt;m_Size--; cout &lt;&lt; &quot;删除成功&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 7.3 测试删除联系人功能在switch case 语句中，case3里添加： case 3: //删除联系人 deletePerson(&amp;abs); break; 测试效果如图： 存在情况： 不存在情况： 8、查找联系人功能描述：按照姓名查看指定联系人信息 查找联系人实现步骤 封装查找联系人函数 测试查找指定联系人 8.1 封装查找联系人函数实现思路：判断用户指定的联系人是否存在，如果存在显示信息，不存在则提示查无此人。 查找联系人代码： //4、查找指定联系人信息 void findPerson(Addressbooks * abs) { cout &lt;&lt; &quot;请输入您要查找的联系人&quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) { cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Name &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;性别：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Sex &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Age &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;电话：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Phone &lt;&lt; &quot;\\t&quot;; cout &lt;&lt; &quot;住址：&quot; &lt;&lt; abs-&gt;personArray[ret].m_Addr &lt;&lt; endl; } else { cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 8.2 测试查找指定联系人在switch case 语句中，case4里添加： case 4: //查找联系人 findPerson(&amp;abs); break; 测试效果如图 存在情况： 不存在情况： 9、修改联系人功能描述：按照姓名重新修改指定联系人 修改联系人实现步骤 封装修改联系人函数 测试修改联系人功能 9.1 封装修改联系人函数实现思路：查找用户输入的联系人，如果查找成功进行修改操作，查找失败提示查无此人 修改联系人代码： //5、修改指定联系人信息 void modifyPerson(Addressbooks * abs) { cout &lt;&lt; &quot;请输入您要修改的联系人&quot; &lt;&lt; endl; string name; cin &gt;&gt; name; int ret = isExist(abs, name); if (ret != -1) { //姓名 string name; cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl; cin &gt;&gt; name; abs-&gt;personArray[ret].m_Name = name; cout &lt;&lt; &quot;请输入性别：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1 -- 男&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2 -- 女&quot; &lt;&lt; endl; //性别 int sex = 0; while (true) { cin &gt;&gt; sex; if (sex == 1 || sex == 2) { abs-&gt;personArray[ret].m_Sex = sex; break; } cout &lt;&lt; &quot;输入有误，请重新输入&quot;; } //年龄 cout &lt;&lt; &quot;请输入年龄：&quot; &lt;&lt; endl; int age = 0; cin &gt;&gt; age; abs-&gt;personArray[ret].m_Age = age; //联系电话 cout &lt;&lt; &quot;请输入联系电话：&quot; &lt;&lt; endl; string phone = &quot;&quot;; cin &gt;&gt; phone; abs-&gt;personArray[ret].m_Phone = phone; //家庭住址 cout &lt;&lt; &quot;请输入家庭住址：&quot; &lt;&lt; endl; string address; cin &gt;&gt; address; abs-&gt;personArray[ret].m_Addr = address; cout &lt;&lt; &quot;修改成功&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;查无此人&quot; &lt;&lt; endl; } system(&quot;pause&quot;); system(&quot;cls&quot;); } 9.2 测试修改联系人功能在switch case 语句中，case 5里添加： case 5: //修改联系人 modifyPerson(&amp;abs); break; 测试效果如图： 查不到指定联系人情况： 查找到联系人，并修改成功： 再次查看通讯录，确认修改完毕 10、清空联系人功能描述：清空通讯录中所有信息 清空联系人实现步骤 封装清空联系人函数 测试清空联系人 10.1 封装清空联系人函数实现思路： 将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置为0，做逻辑清空即可。 清空联系人代码： //6、清空所有联系人 void cleanPerson(Addressbooks * abs) { abs-&gt;m_Size = 0; cout &lt;&lt; &quot;通讯录已清空&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); } 10.2 测试清空联系人在switch case 语句中，case 6 里添加： case 6: //清空联系人 cleanPerson(&amp;abs); break; 测试效果如图： 清空通讯录 再次查看信息，显示记录为空 至此，通讯录管理系统完成！","categories":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第一阶段","slug":"C-教程/C-第一阶段","permalink":"/categories/C-教程/C-第一阶段/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++教程","slug":"C-教程","permalink":"/categories/C-教程/"},{"name":"C++第一阶段","slug":"C-教程/C-第一阶段","permalink":"/categories/C-教程/C-第一阶段/"}]},{"title":"《王杰》重制","slug":"《王杰》重制","date":"2021-01-19T05:56:02.000Z","updated":"2021-02-03T07:08:53.215Z","comments":true,"path":"2021/01/19/《王杰》重制/","link":"","permalink":"/2021/01/19/《王杰》重制/","excerpt":"","text":"一年前的这个时候，是我第一次做视频，第一次录音，效果和自己想表达的，都很不理想！那么，现在我打算重制这个视频。我还想和某些人说一声，这个世界上没有什么是一尘不染的，我们都在吸进灰尘，这并不妨碍我们变得好一点，相信美好的一面啊。我觉得一个人有缺点才是有血有肉的人，每个人多多少少都会存在缺点。话说回来，王杰受争议的各种言论给他带来了什么？他是靠那些来挣钱的？你如果是王杰，你会为了红，说出所谓“漏洞百出”的话么？或许就是年龄的原因，生活中的各种境遇，才会如此，但并不是你在网上谩骂的理由，我更好奇，天天自己搜集，更新污点视频是有多闲的，没有自己的生活么？我做这个视频也是年更一次，平常根本没有时间。还有，如果你不喜欢王杰，现在请自行退出，谢谢合作！出生于1962年的王杰，在1980年代到90年代活跃在华语乐坛，名列台湾四大天王之一。 第一张专辑《一场游戏一场梦》1987年，在被滚石唱片拒绝后，在制作人李寿全的赏识之下，加盟台湾飞碟唱片公司，“为什么道别离，说什么在一起，如今虽然没有你，我还是我自己。”《一场游戏一场梦》就这样横空出世，清亮而伤感的歌声，夹杂着摩托车的噪音从路旁呼啸而过，在空气里久久回荡。有人说失恋别听王杰，他的歌声犹如一个超强磁场，一靠近就再也无法忘怀。所以，他一出道便惊艳了整个华语乐坛。推出不久后销售便突破30万张（现已累计破千万张），雄霸排行榜冠军长达半年之久，成为当时乐坛最受瞩目的黑马。 第二张专辑《忘了你忘了我》1988年7月11日， 第二张专辑《忘了你忘了我》，创造销售热潮，突破50万张，《你是我胸口永远的痛》登上新加坡龙虎榜冠军勇套年度亚军，直逼当时的天皇谭咏麟，《是否我真的一无所有》缔造历史新纪录及奇迹，销量突破60万张，而在马来西亚方面，王杰两张专辑均突破双白金，创下当地罕见的销量纪录。 第三张专辑《是否我真的一无所有》1989年1月18日， 第三张专辑《是否我真的一无所有》，推出不久后销量便突破50万大关，再度缔造新纪录，而主打歌「是否我真的一无所有」的MV中，邀请刘德华共同演出。王杰于2月进军香港，加盟华纳唱片，推出首张粤语专辑《故事的角色》，连续24周保持在全港中文唱片销量榜「十大」之内（其中有16周高踞销量榜三甲之内），销量破5白金，成为第一位首次出片销量即过5白金的歌手，造成香港乐坛轰动，王杰旋即成为各大片商及演唱会经济人争相邀约的对象，专辑中的歌曲「可能」、「还有」、「故事的角色」均打进香港中文歌曲龙虎榜前10名。 第四张专辑《孤星》1989年8月10日，发行第四张专辑《孤星》，香港推出第二张粤语专辑《谁明浪子心》，连续三週高踞销量榜冠军，主打歌「谁明浪子心」于香港大红，更让王杰气势一时无两。 第五张专辑《向太阳怒吼》1990年1月7日发行第五张国语专辑《向太阳怒吼》，是王杰成立WANG音乐工作室后，第一张自己参与制作的国语专辑。主打歌「向太阳怒吼」在台湾中广知音时间排行榜上蝉联4周冠军，连同第二主打歌「别让明天的太阳离开我」在榜上共停留18周，另外亦在新加坡电台龙虎榜、大马电台翡翠龙虎榜、马来西亚十大排行榜、台湾十大龙虎榜均拿下冠军。并于1月份香港推出第二张粤语专辑《谁明浪子心》，连续三週高踞销量榜冠军，香港三大音乐颁奖礼上横扫所有新人奖项，为台湾湾第一位创下此纪录之歌手，并且凭藉《谁明浪子心》拿下「十大劲歌金曲奖」、「十大中文金曲奖」两项大奖，更获得香港作曲家及作词家协会颁发的最佳作曲奖 第六张专辑《我要飞》1990年5月1日，发行第六张国语专辑《我要飞》，由于和上张专辑发行仅差四个月，上张专辑的曲目尚未退榜时，新专辑的歌曲就紧接登上知音时间排行榜。虽然与上张专辑发行的时间点相当接近，但「我要飞」依旧在金曲龙虎榜有着不错的成绩（进榜16周）。王杰主演的《养子不教谁之过》主题曲，片尾曲也都收录在这张专辑中。 第七张专辑《为了爱梦一生》1991年 1月，推出第七张国语专辑《为了爱梦一生》，也是王杰歌唱事业攀上第二个高峰。 5月，推出粤语精选辑《今生无悔》出片当周旋即登上排行榜宝座，蝉联7周销售冠军。 第八张专辑《忘记你不如忘记自己》1991年 7月，推出第八张国语专辑《忘记你不如忘记自己》。出片双週销售即破20万张；王杰于一年内连续推出三张唱片均创下白金佳绩，《忘记你不如忘记自己》荣登民生报「金曲龙虎榜」秋季排行总冠军。11月，《为了爱梦一生》入围第三届金曲奖最佳专辑奖。出道5年内，王杰国、粤语计13张专辑销售已超过一千万张，香港华纳公司举行「王杰飞越200白金新纪元」庆祝会以兹庆祝 第九张专辑《All By Himself》1992年 1月出版第九张国语专辑《All By Himself》，专辑内词曲全由王杰包办，销售突破8白金，1992亚洲华语唱片排行榜第第五名。 第十张专辑《英雄泪》1992年7月发行个人第十张国语专辑《英雄泪》，此张专辑王杰滞港未做宣传，销售依旧突破8白金，1992亚洲华语唱片排行榜第一名。 首张个人单曲专辑《回家》1992年10月发行首张个人单曲专辑《回家》，也是台湾史上首张以单曲型态出版的专辑销量突破25万张，并且1993年 王杰作为台湾的演唱代表，在大陆中央电视台举办的春节晚会节目中，演唱歌曲「回家」（两岸即时连线播出，王杰本人并未到大陆现场） 第十一、十二、十三张专辑《我》《路》《只要说你爱我》1993年4月27日，王杰因奉子成婚与妻子莫绮雯于台北君悦大饭店举行盛大的婚礼，政商界人士与演艺圈的好友均参与王杰的婚礼。王杰于此年推出的两张国语专辑《我》、《路》、粤语专辑《她》销量与口碑亦有不错成绩。当年11月儿子出生。1994年 由于王杰长久以来负荷相当大的工作量，身体早已出现警讯，王杰罹患了厌食症，体重下滑仅剩40多公斤，医师告诫王杰需停止工作进行疗养，因此王杰与妻子移民加拿大，自此也开始减少在荧光幕前出现，惟发片时才会从加拿大回来台湾进行短暂宣传，因月初发行《只要说你爱我》，王杰回台举办小型歌友会，师弟林志颖、苏有朋与师妹王韵婵均担任嘉宾，而此专辑销量突破24万张。 第十四张专辑《候鸟》7月，推出第十四张国语专辑《候鸟》，主打歌「爱得太多」MTV创下在台湾三台无线电视联播的创举。王杰于此年推出的两张国语专辑《梦在无梦的夜裡》、《情愿不自由》反应与销量皆不如以往；不久王杰与飞碟唱片、香港华纳唱片约满，于年底加盟波丽佳音唱片公司，至此王杰的巅峰期结束。从出道开始，王杰便马不停蹄地工作，出专辑加上拍戏，广告、演出、采访，档期满满当当，演唱会从来没有嘉宾，一个人从头唱到尾几个小时不间断。整日的奔波，王杰的体重从130斤降到90斤，还经常伴随胃吐血和绞痛，身体几乎垮掉。无奈，只能选择退隐远赴加拿大休养身体。处于事业巅峰的王杰，就这样渐渐淡出主流视野。复出后，流行乐坛正式进入偶像时代，此时的王杰，境况早已不可同日而语。世事一场大梦，人生几度悲凉。在2018年的12月19日，55岁的王杰发行了最后一张创作专辑《我知道我是一个过气的歌手》，他曾经这样说过 我不善言语只能用歌来表达自己的情感与遭遇我只做自己只能用真心真意对待所有的朋友无需谅解我也无需懂我因为永远没有人了解我世界上所有的人、事、物在我眼里都是美丽的······","categories":[{"name":"人物","slug":"人物","permalink":"/categories/人物/"}],"tags":[{"name":"自媒体","slug":"自媒体","permalink":"/tags/自媒体/"}],"keywords":[{"name":"人物","slug":"人物","permalink":"/categories/人物/"}]},{"title":"甲午战争始末01：平壤之战","slug":"甲午战争始末：平壤之战","date":"2021-01-18T03:18:09.000Z","updated":"2021-02-02T16:38:57.833Z","comments":true,"path":"2021/01/18/甲午战争始末：平壤之战/","link":"","permalink":"/2021/01/18/甲午战争始末：平壤之战/","excerpt":"","text":"在清日两国交涉之际，驻扎在牙山的清军提督叶志超派出一支部队前往全州侦查，总兵聂士成为求战功，与叶志超商议后，自己率兵前往全州剿灭东学党，袁世凯得知后，急忙电告聂士成迅速撤回牙山，大规模行动不适合两国谈判的进行。然而，总兵聂士成并没有听从。7月10日，经多次袁世凯劝告之后，聂士成率部撤回牙山。清军提督叶志超也一再提醒李鸿章应继续派兵入朝，而李鸿章选择政治斡旋的方式，试图和平解决朝鲜战事，命叶志超不可轻举妄动，等待朝廷的最后决定。清日谈判破裂后，在7月19日朝廷命李鸿章开始向朝鲜大举增兵。清军北塘、芦台、天津的仁字营、仁字副营、武毅军步兵1300名，于7月21日分乘英国轮船“飞鲸”、“爱仁”号从大沽出发，23日进入牙山湾，24日在白石浦登陆。天津练军、亲兵前营、护卫营炮兵，计1200名，炮12门，23日后午后乘英国汽船“高升”号从大沽出发，途中与通报舰“操江”汇合。两舰25日早上到达牙山近海时，护送飞鲸”、“爱仁”号的“济远”，“广乙”两舰和日本舰队正在进行遭遇战，“高升“号英国人舰长自以为日本人不敢对英国的舰队动武，直闯战斗海域，卷入两军的战斗，随后，便遭到日本“浪速”舰的拦截，并击沉了载有1200名官兵的“高升”号。7月23日，入朝日军入侵朝鲜王宫，控制了国王，并护送临时扶植的朝鲜傀儡政权大院君进入景福宫。大院君入宫后组成临时政府，宣布废除朝鲜国与清国间所有条约，并邀请日军驱逐在朝清军，两国当日签订了同盟国条约。结果增援牙山的清军，只有英国轮船“飞鲸”、“爱仁”号运送的1300名官兵与叶志超军汇合，此时，牙山的守军增至3880名。由于作战对象由东学党转为日军和朝鲜傀儡政权，聂士成提议在成欢布阵，随后，聂士成率领武毅军副中营和老前营、正定练军中营、古北口练军中营和后营马队，合计2040名清兵、炮8门前往成欢。翌日午前，叶帅分兵两路相隔遥远之处为聂军后援，这种违背作战原则的战法，令日军百思不得其解。7月25日，占领京城的大岛混成旅团，步兵3500人，骑兵47骑，山炮8门，准备向牙山进军时，发生了雇佣的朝鲜民夫拐走军粮的逃跑事件，当时的日军很难雇佣到民夫，由此可见，当时的朝鲜人民对日本人是抵触的。再加上朝鲜地势险峻，山路崎岖，日军原计划的陆地战不得不向后推迟。两天后的7月27日，日军通过侦察兵侦查得知，清军主力已经移师成欢，在成欢周围的山地构筑工事。29日，日军武田12中队右翼前卫在途径佳龙龙附近时，遭到清军的阻击，许多士兵掉入河中，伤亡颇多。随后，大岛旅团的左翼部队向月峰山、坊主山、新井里进攻。聂士成指挥部队占据有利地形痛击日军，压制了日军的火力。但，此时配置在宝莲山的日军炮兵向清军阵地发起猛烈炮击，榴霰弹在空中开花，清军伤亡惨重。可是位于牛歇里的清军炮兵相距太远，无法达到日军炮兵阵地。在日军优势火力的攻击下，清军大面积溃退，而此时驻守天安的叶志超心中胆怯，按兵不动，并没有增援聂士成的部队。聂士成被逼只好丢弃辎重武器，向天安方向遁逃。逃亡路上的清军因丢弃粮食，一路饿着肚子，所以沿途洗劫朝鲜民家食品财物。对于败阵的清军洗劫，朝鲜民众开始视清军为仇敌，而对军纪严明的日军表现出友善的态度。","categories":[{"name":"甲午战争","slug":"甲午战争","permalink":"/categories/甲午战争/"}],"tags":[{"name":"晚清历史","slug":"晚清历史","permalink":"/tags/晚清历史/"},{"name":"自媒体","slug":"自媒体","permalink":"/tags/自媒体/"}],"keywords":[{"name":"甲午战争","slug":"甲午战争","permalink":"/categories/甲午战争/"}]},{"title":"C++中头文件iostream介绍","slug":"C-中头文件iostream介绍","date":"2021-01-17T10:38:06.000Z","updated":"2021-01-28T03:59:07.914Z","comments":true,"path":"2021/01/17/C-中头文件iostream介绍/","link":"","permalink":"/2021/01/17/C-中头文件iostream介绍/","excerpt":"","text":"C++语言不直接处理输入输出，而是通过一簇定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，即，从string读取数据，向string写入数据。 C++/C++11中头文件定义了标准输入/输出流对象。包含了也自动包含了、、、和。 头文件中的对象包括： (1)、narrow characters(char)即窄字符：cin(standard input stream (object))、cout(standard output stream (object))、cerr(standard output stream for errors (object))、clog(standard output stream for logging (object))； (2)、wide characters(wchar_t)即宽字符：wcin(standard input stream (wide) (object))、wcout(standard output stream (wide) (object))、wcerr(standard output stream for errors (wide) (object))、wclog(standard output stream for logging (wide) (object))。 IO库： (1)、istream(输入流)类型，提供输入操作； (2)、ostream(输出流)类型，提供输出操作； (3)、cin，一个istream对象，标准输入流，用来从标准输入读取数据； (4)、cout，一个ostream对象，标准输出流，从标准输出写入数据，输出可以重定向( “&gt;” 或“1&gt;”)到一个指定文件中；用于将数据写入标准输出，通常用于程序的正常输出内容。 (5)、cerr，一个ostream对象，标准错误流，通常用于输出程序错误信息或与其它不属于正常逻辑的输出内容，写入到标准错误，默认情况下，写到cerr的数据是不缓冲的；错误信息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示；可以通过” 2&gt; ”方式重定向输出到指定文件中；cerr通常用于输出错误信息或其它不属于程序正常逻辑的输出内容。 (6)、clog：一个ostream对象，标准错误流，关联到标准错误；与cerr区别：cerr和clog都是标准错误流，区别在于cerr不经过缓冲区，直接向显示器输出信息，而clog中的信息默认会存放在缓冲区，缓冲区满或者遇到endl时才输出；默认情况下，写到clog的数据是被缓冲的。clog通常用于报告程序的执行信息，存入一个日志文件中。 (7)、&gt;&gt;运算符，用来从一个istream对象读取输入数据； (8)、&lt;&lt;运算符，用来向一个ostream对象写入输出数据； (9)、getline函数，从一个给定的istream读取一行数据，存入一个给定的string对象中。 IO库类型和头文件：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型，如下图： 为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。例如，wcin、wcout和wcerr是分别对应cin、cout和cerr的宽字符版对象。宽字符版本的类型和对象与其对应的普通char版本的类型定义在同一个头文件中。","categories":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}]},{"title":"C++——析构函数什么时候被调用","slug":"C-——析构函数什么时候被调用","date":"2021-01-17T08:31:17.000Z","updated":"2021-01-28T03:59:07.913Z","comments":true,"path":"2021/01/17/C-——析构函数什么时候被调用/","link":"","permalink":"/2021/01/17/C-——析构函数什么时候被调用/","excerpt":"","text":"1、对象生命周期结束，被销毁时 2、delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类析构函数是虚函数时； 3、对象A是对象B的成员，B的析构函数被调用时，对象A的析构函数也被调用。","categories":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}]},{"title":"C++中::的作用","slug":"C-中-的作用","date":"2021-01-15T13:23:20.000Z","updated":"2021-01-28T03:59:07.914Z","comments":true,"path":"2021/01/15/C-中-的作用/","link":"","permalink":"/2021/01/15/C-中-的作用/","excerpt":"","text":"表示作用域和所属关系，用来调用类内的静态成员函数，或者定义类的成员函数。 PS：静态成员函数的作用：静态成员函数总结：静态成员函数是类中的特殊的成员函数静态成员函数没有隐藏的this指针：当调用一个对象的非静态成员函数时，系统会将该对象的起始地址赋值给成员函数的this指针．但是，静态成员函数不属于某个对象，为该类的所有对象共享，所以静态成员函数没有this指针．静态成员函数可以通过类名直接访问静态成员函数可以通过对象访问静态成员函数只能直接访问静态成员变量（函数），而不能直接访问普通成员变量（函数）","categories":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}],"tags":[{"name":"C++","slug":"C","permalink":"/tags/C/"},{"name":"编程","slug":"编程","permalink":"/tags/编程/"}],"keywords":[{"name":"C++编程笔记","slug":"C-编程笔记","permalink":"/categories/C-编程笔记/"}]}]}